# Before Version Control
diff -u file1 file2 > changes.diff
patch file1 < changes.diff


---------------------------------------------------------------------------------------------------------------------------------
git / github

distributed - each developer has a copy of the whole repository on their local machine

git directory  - contains the history of all the files and changes
working tree   - contains current state of the project and all current versions of the files
staging area   - all changes that go into next commit

tracked / untracked files   - tracked files are part of the snapshots (git commit) while untracked aren't (yet)
                            - git add: adds file to tracked files
each file can be in one state: 
    - Modified    (changes - i.e. modifying, adding, deleting lines - made to file that has not been committed yet)
    - Staged      (files are ready for commitment; all staged files will be part of next commit) via git add
    - Commmitted  (changes are stored in VCS)

git Workflow
    git init/clone - git add file - git commit - edit file - git add file - git commit
file is                 tracked     committed    modified       staged      committed
             OR
    git init/clone - git add file - git commit - edit file -                git commit -a
file is                 tracked     committed    modified                  staged & committed

Branches
HEAD           - represents currently checked-out snapshot (like a bookmark; pointer to the current branch)
branches point to commits as well
in git log it is shown to which commit ids the different branches (and HEAD) point
here it is clear which branch is ahead and which one is behind

Merging:
fast-forward merge
    this kind of merge takes place if both branches share the same history of commits so one branch is just ... commits before the other one (quite linear)
    git just updates the pointers of the branches to point to the same commit-id
three-way merge
    history of git log diverges on both branches
    Git will tie the branch histories together with a new commit and merge the snapshots at the two branch tips with the most recent common ancestor, 
    the commit before the divergence. Git tries to figure out how to combine both snapshots. If the changes were made in different files, or in 
    different parts of the same file, Git will take both changes and put them together in the result. If instead the changes are made on the same part 
    of the same file, Git won't know how to merge those changes, and the attempt will result in a merge conflict.

Merge Conflict
    git shows if there is a merge conflict; then use 'git status'
    git sets merger markers in the conflict file; edit conflicting file and chose which parts to take over
    add changed file to staged files: 'git add file_without_conflict'
    after solving the conflict, execute 'git commit'

commit message: 1 line < 51 characters - 1 blank line - detailed description of changes in several lines but each line < 72 characters

------git commands------------------------------------------------------------------------------------------------------------------------

git config --global user.name 'Marc Backwinkel'
git config --global user.email 'marc.backwinkel@gmail.com'
git config --global credential.helper cache                 # caches our credentials for a time window (15 Min) so that we don't need to enter our password 
                                                            #     with every interaction to github; alternative to SSH key pair
        git config -l         # list actual config

git init                             -> creates .git (git directory), initializes git repository
  or
git clone url                        -> copies .git locally (git directory)
git add file_to_add_to_project.py    # adds file to project and to staging area
          git add *                  # add all files to staging area
          git add -p                 # git will add for every change to be taken over
git mv old_name new_name             # file is renamed in git; change must be committed
git rm file                          # deletes file from git directory; change needs to be committed 
git status                           # show outstanding changes
git commit                           # save changes; git creates snapshots of project on each commit
         git commit -a               # shortcut to stage any changes to TRACKED files and commit them in one step; untracked files cannot be included
         git commit --amend          # overwrites previous commit (includes last commit and this commit); further commit message can be modified
                                     # ONLY use git commit --amend on local repositories as it may confuse on public repositories
         git commit -m 'commit message'     # only use for short commit messages
git push                             # sends all collected snapshot to the online repository; all changes must be committed
git pull                             # retrieve new changes from the repository
git log                              # show all commit messages
         git log -p                  # equivalent to diff -u; shows differences between different versions
         git log -p -2               # show last two items from log file
         git log --stat              # shows log and which files were changed and how many lines were added / removed
         git log --graph --oneline   # shows history of commits and branches in a graphical view
git diff file                        # shows differences between file.last_snapshot file.actual_version; shows only UNSTAGED changes
         git diff --staged           # show changes that are staged but not committed
git show commit_id                   # shows information for version_id and the corresponding patch


git checkout file                    # restore working tree files
                                     # revert file to latest stored snapshot; works on unstaged changes (not git added)
                                     # it reverts changes to modified files before they are staged
git checkout BRANCH                  # switch to another branch
         git checkout -b new_BRANCH  # create new branch and switch to it

         git checkout -p file        # checkout individual changes; asks change by change if you want to go to the last snapshot
git reset HEAD file                  # basically resets the repo, throwing away some changes
                                     # remove file from staging area compared to last snapshot
                                     # reset changes to what is in the current snapshot
         git reset -p                # git asks for which specific changes shall be reset

git revert HEAD                      # rollback to previous snapshot as a new commit
git revert commit_id                 # rollback to defined commit id


git branch                           # shows existing branch structure of repository, actual branch is marked with asterisk
git branch new_branch_name           # create new branch
git branch -d branch_name            # delete branch; use 'git branch -D branch_name' if branch is not fully merged 

git merge branch_name                # merges the working directory of the branch_name into the actual branch we are in, e.g. master
        git merge --abort            # escape hatch: stop the merge and reset the files in the working tree back to the previous commit 
                                     #               before the merge ever happened


--------------------------------------------------------------------------------------------------------------------------------------------
.git
      working directory, created with git init or git clone
.gitignore
     file in root directory that contains files which are ignored by git status
     echo file_to_ignore.txt > .gitignore
     .gitignore needs to be added (git add .gitignore) and committed (git commit)
