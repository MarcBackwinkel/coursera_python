Troubleshooting         The process of identifying, analyzing and solving problems.
Debugging               The process of identifying, analyzing and removing bugs in a system.

Reproduction Case       A clear description of how and when the problem appears; a way to verify if the problem is present or not
Root Cause              Understanding the root cause is essential for performing the long-term remediation
    Hypothesis          Whenever possible, we should check our hyothesis in a test environment, instead of our production envirenment 
                                that our users are working with. 
System Calls            Calls that the programs running on our computer make to the running kernel
Observer Effect         Oberving a phenomenon alters the phenomenon
Power cycling           releases resources stored in cache or memory, which gets rid of the problem

Bisecting               cut problem in half and test each half seperately
                        cut possiblities for crash in half and test first half
                                 if first half causes the failure, the fault is in this group; else it's in the second
                                 continue further
                        there is also a command "git bisect"!?
                        
Cache                   Stores data in a form that is faster to access than its original form
                        e.g. Web Proxy: stores documents, videos, pictures often downloaded from the Internet
                        e.g. DNS-Services: store IP adresses for urls
Memory Leak             Memory which is no longer needed is not getting released


Problem Solving Steps
1. Getting Information
2. Finding the root cause
3. Performing the necessary remediation

----------------------------------------------------------------------------------------------------------------------------
Tools

ab                            # Apache Benchmark-Tool for benchmarking HTTP server
    ab -n 500 url             # get average timing of 500 requests
kill                          # kills a process
    kill -CONT                # continue stopped program, if program is still running, nothing will happen
    kill -STOP                # stops a program which can be continued or terminated
killall -STOP program_name    # stops program(s) with program_name, but does not kill them
strace                        # logs system calls, e.g. "strace ./run_program.py"
    strace -o file program    # store output to a file
iftop                         # shows network traffic
ionice                        # make our problem system reduce its priority
iostat                        # shows statistics on the input/output operations    
iotop                         # shows which processes use the most input and output
locate                        # find a given file
nice                          # start process with a different priority
pidof                         # receives a process name and returns all corresponding process ids
ps
    ps ax                     # show all running processes on computer
renice                        # change priority of a running process
                              #           the lower the process priority number the higher the priority; typcial numbers go from 0 - 19
                              #           by default, processes start with a priority of 0
        renice priority pid   # e.g. for pid in $(pidof ffmpeg); do renice 19 $pid; done                
top                           # shows state of computer and processes using the most cpu
                              # Load Average: shows how long a processer is busy in a given minute with 1 meaning it was busy all the time
                              #               normally this number should not be greater than the number of processors
                              #               if it is higher than the computer is overloaded
vmstat                        # shows statistics on the virtual memory operations


tcpdump                       # powerful command-line analyzer that captures or "sniffs" TCP/IP packets
wireshark                     # open source tool for profiling network traffic and analyzing TCP/IP packets


# Script to continue STOPPED processes, one by one
# Continue first process (pid) and wait 1 second; continue process again, wait, ... until first pid does not exist any longer; head one to second pid
for pid in $(pidof ffmpeg); do while kill -CONT $pid; do sleep 1; done; done

----------------------------------------------------------------------------------------------------------------------------
Getting Information

- What were you trying to do? 
- What steps did you follow? 
- What was the expected result? 
- What was the actual result?

Find out, why computer is slow?
1. WHEN is the computer slow?


- Consider simplest explanation first!

System Logs:
  - on Linux:       /var/log/syslog
                    .xsession-errors
  - on Mac OS       /Library/Logs
  - on Windows      Event Viewer
  
-----------------------------------------------------------------------------------------------------------------------------
Linear Search        search from top to bottom
Binary Search        list must be sorted (sorting takes no time), but honestly does not make any sense if just one element is searched
                     compare to the middle element
                     > search in the second half, especially compare the middle element of the second half
                     < search in the first half, especially compare the middle element of the first half


-----------------------------------------------------------------------------------------------------------------------------
Efficient Code

- we should always start by writing clear code that does what it should and only try to make it faster if we realize that it's not fast enough
- trying to optimize every second out of a script is probably not worth your time.
- If we want our code to finish faster, we need to make our computer do less work, by
            - storing data that was already calculated to avoid calculating it again 
            - using the right data structures for the problem and 
            - reorganizing the code so that the computer can stay busy while waiting for information from slow sources like disk or over the network
            
Profiler            is a tool that measures the resources that our code is using, giving us a better understanding of what's going
                    -> use gprof to analyze a C program but use the c-Profile module to analyze a Python program
                
expensive actions   are those that take a long time to complete

Lists

    Lists are sequences of elements. We can add, remove, or modify the elements in them. We can iterate through the whole list to operate on each of 
    the elements. Different programming languages call them differently. 
    The structure is called ArrayList in Java, Vector in C++, Array in Ruby, and Slice in Go.

    fast 
        to add or remove elements at the end. 
    slow
        But adding or removing elements in the middle can be slow because all the elements that follow need to be repositioned. 
    fast
        It's fast to access the element in a specific position in the list, 
    slow
        but finding an element in an unknown position requires going through the whole list. This can be super slow if the list is long. 

Dictionary        
 
    Dictionary store key value pairs. We add data by associating a value to a key. Then, we retrieve a value by looking up a specific key. 
    They are called HashMap in Java, Unordered Map in C++, Hash in Ruby, and Map in Go. 
     
     fast
         super-fast for looking up keys. Once we have our data stored in a dictionary, we can find the value associated to a key in just one operation. 
         
==> If you need to access elements by position or will always iterate through all the elements, use a list to store them. 
==> If we need to look up the elements using a key, we'll use a dictionary.


Expansive Loops ------------------------
If you do an expensive operation inside a loop, you multiply the time it takes to do the expensive operation by the amount of times you repeat the loop

- Make sure that the list of elements that you're iterating through is only as long as you really need it to be
- break out of the loop once you found what you were looking for (using "break" in python)
- the right solution for one problem might not be right for a different problem






































