Steps for coding Projects.

    1. Understand the problem statement
    2. Research
    3. Planning
    4. Writing / Testing
    
#=============================================================================================================================================================
# Modules in Python

pip install module_name

Importing Modules:
from email.message import EmailMessage
import json
from mailbox import MaildirMessage
from re import L
from subprocess import CREATE_DEFAULT_ERROR_MODE
from typing import ValuesView
import module      # when module is imported, __init__.py is read

import module sys               # The sys module provides information about the Python interpreter's constants, functions, and methods. 
import module os                # The os module provides a portable way of using operating system dependent functionality with Python.

module: requests                # module for http-requests
import requests
response = requests.get("http://www.google.com")
print(response.text)

module: datetime                 # convert between different time formats

module: arrow                      # date handling
date = arrow.get('2022-08-10', 'YYYY-MM-DD')     # parse string to date
date.shift(weeks=+6).format('MMM DD YYYY')   # add 4 weeks to date and 
                                                                                     # format output
 
module: pil                             # python image library
image = PIL.Image.open('picture.jpg')
print(image.size, image.format)

module: shutil                        # system health
du = shutil.disk_usage('/')
module: psutil                        # performance monitoring
psutil.cpu_percent(0.1)


Running python-modules on Linux
use shebang: #!/usr/bin/env python3
chmod +x                             # mark script as executable
./script.py


Working with Files
file = open("file.txt","w")        # second parameter: r -> read mode (default), w -> write only mode, a -> append, r+ -> read-write mode
                                    # if file is opened for writing and it already exists, the old contents are deleted as soon as the file is opened
file.readline()                    # reads file line by line, puts an \n automatically to the end <-- can be removed with strip()
file.read()                        # reads file till the end
lines = file.readlines()           # reads all lines of a file and returns them as list
file.write("text")                 # returns number of characters that were written
file.close()
or
with open("file.txt") as file:      # with automatically closes file after with block is left
    print(file.readline())
    
    
Working with the file system
import os
os.getcwd()                            # get current working directory
os.listdir("dir")                      # returns a list of all files in the directory
path = os.path.join("dir", "file.txt") # combines directory and file name os independently
os.path.isdir("is_this_a_dir")         # check if parameter is a directory, eventually combine name with os.path.join("dir", "file.txt")
os.mkdir("new_dir")
os.rmdir("dir_to_remove")              # will only remove a directory if the directory is empty
os.chdir("new_dir")
os.path.exists("filename.txt")         # check if a file exists, returns True / False
os.path.getsize("filename.txt")        # filesize
ts = os.path.getmtime("filename.tx")   # last timestamp of modification; timestamp in milliseconds
    datetime.datetime.fromtimestamp(ts) # format timestamp as actual date / attention: previously import datetime-module!    
abs_path = os.path.abspath("file.txt") # returns absolute path to file
os.remove("file_to_be_deleted.txt")    # remove file
os.rename("old_name.txt", "new_name.txt")


csv-Files
import csv
f = open("csv_file.txt")                # use attributes w and a to write to csv-file
csv_f = csv.reader(f)
for row in csv_f:                     # read csv-file
    col1, col2, col3 = row              # unpack values, col1 == row[0]
    
with open('file.csv', 'w') as file_csv:  # write to a csv-file with a list
    writer = csv.writer(file_csv)
    writer.writerow([value1, value2, value3])    # writes a single row to a csv file
    writer.writerows([[value1, value2, value3], [value4, value5, value6]])     # write list of lists to a csv file 
    
with open('file.csv') as file_csv:  # read csv-file into a dict
    reader = csv.DictReader(file_csv)     # reads a file into a dict, using first row as keys
    
with open('file.csv', 'w') as file_csv:  # write to csv-file using a dict
    writer = csv.DictWriter(file_csv, fieldnames=keys)     # keys is a list of the key names
    writer.writeheader()
    writer.writerows(dict)               # dict is a dictionary, which keys are identical to the list-variable keys
    
#=============================================================================================================================================================

Regular Expressions

RegEx
.      matches any character (wildcard)
^      position must match the beginning
$      position must match the end
()     capturing group
[]     define a range, e.g. [pP], [a-z], [a-zA-Z0-9], [.,:;?!]
[^]    define a range which is excluded [^a-zA-Z ] (exclude any letter - case insensitive - and space)
|      separate words to find
repeated match qualifiers
*      match any number of chars incl. zero times; it works "greedy" (matches as many characters as possible)
+      match any number of chars at least one time; it works "greedy" (matches as many characters as possible)
?      character before is optional, like p? or [a-z]?
{}     numeric repetition qualifiers, e.g. {5}, {1,5}
Escpaing characters
.*+?^$[]{}
Special Sequences
\b     word boundaries, e.g. r'\b[a-zA-Z]{5}\b' all words with exactly 5 characters
\d     digits
\s     whitespace characters (like space, tab, newline \n
\w     any alphanumeric character (incl. letters, numbers, underscores)

import re
result = re.search(r'regex_as_string', text_to_be_looked_at)    # r -> Rawstring shall not be interpreted by Python but shall be handed to the function as is
                                                                # if Rawstring is a pure text string, then the 'r' would not be needed
                                                                # but: Always use Rawstrings for regular expressions in Python!!!
                                                                # result is a re.Match object <; span, match = matching_string>; if nothing is found None is returned
                                                                # re.Match object is a tuple, [0]: all results, [1]: first group, [2]: second group, ...
                                                                         # groups are built acc. to parenthesis in reg ex-string, e.g. r'(\w+), (\w+)' 
re.search(r'regex', text, re.IGNORECASE())  # search case insensitive
re.findall(r'regex', text)                  # find all matches, returns a list with all results
re.split(r'regex', text)                    # splits a text into different strings using regex
re.sub(r'regex', new_text, text)            # replaces regex-strings in text by new_text
                                            # new_text may also be a regex, e.g. to access captured groups: r'\2 \1' (second_group first_group)

bash-Commands
grep
-i  : search case insensitive
egrep                                       # also supports + and ? as repeated match qualifiers 

#=============================================================================================================================================================
Data Serialization

JSON - Javascript Object Notation
# JSON is used frequently for transmitting data between web services

import json
with open('people.json', 'w') as people_json:
    json.dump(original_object, json_object, indent=4)   # serializes original object --> json format 

[
    {
        "att11": "value11",
        "att12": "value12",
        {
            "dict_att11": "dict_value11",
            "dict_att12": "dict_value12"
        }
    },
    {
        "att21": "value21",
        "att22": "value22",
        {
            "dict_att21": "dict_value21",
            "dict_att22": "dict_value22"
        }
    },
    {
        ...
    }
]

# JSON has strings, which are enclosed in quotes                                    "string"
# JSON has integers                                                                 42
# JSON has objects, which are key-value pair structures like Python dictionaries    {
                                                                                      "name": "Sabrina Green",
                                                                                      "username": "sgreen",
                                                                                      "uid": 1002
                                                                                    }
# And a key-value pair can contain another object as a value. 
# JSON has arrays, which are equivalent to Python lists. Arrays can contain strings, numbers, objects, or other arrays.  
                                                                                    [
                                                                                      "apple",
                                                                                      "banana",
                                                                                      12345,
                                                                                      67890,
                                                                                      {
                                                                                        "name": "Sabrina Green",
                                                                                        "username": "sgreen",
                                                                                        "phone": {
                                                                                        "office": "802-867-5309",
                                                                                        "cell": "802-867-5310"
                                                                                        },
                                                                                        "department": "IT Infrastructure",
                                                                                        "role": "Systems Administrator"
                                                                                      }
                                                                                    ]

# json-File:
import json

people = [
  {
    "name": "Sabrina Green",
    "username": "sgreen",
    "phone": {
      "office": "802-867-5309",
      "cell": "802-867-5310"
    },
    "department": "IT Infrastructure",
    "role": "Systems Administrator"
  },
  {
    "name": "Eli Jones",
    "username": "ejones",
    "phone": {
      "office": "684-348-1127"
    },
    "department": "IT Infrastructure",
    "role": "IT Specialist"
  }
]

with open('people.json', 'w') as people_json:
    json.dump(people, people_json)

# json-dump people_json:
[{"name": "Sabrina Green", "username": "sgreen", "phone": {"office": "802-867-5309", "cell": "802-867-5310"}, "department": "IT Infrastructure", "role": "Systems Administrator"}, {"name": "Eli Jones", "username": "ejones", "phone": {"office": "684-348-1127"}, "department": "IT Infrastructure", "role": "IT Specialist"}]

# use indent-parameter to make it more readable:
with open('people.json', 'w') as people_json:
    json.dump(people, people_json, indent=2)

# resulting file:
[
  {
    "name": "Sabrina Green",
    "username": "sgreen",
    "phone": {
      "office": "802-867-5309",
      "cell": "802-867-5310"
    },
    "department": "IT Infrastructure",
    "role": "Systems Administrator"
  },
  {
    "name": "Eli Jones",
    "username": "ejones",
    "phone": {
      "office": "684-348-1127"
    },
    "department": "IT Infrastructure",
    "role": "IT Specialist"
  }
]

# Another option is to use the dumps() method, which also serializes Python objects, 
# but returns a string instead of writing directly to a file. 
people_json = json.dumps(people)
print(people_json)
[{"name": "Sabrina Green", "username": "sgreen", "phone": {"office": "802-867-5309", "cell": "802-867-5310"}, "department": "IT Infrastructure", "role": "Systems Administrator"}, {"name": "Eli Jones", "username": "ejones", "phone": {"office": "684-348-1127"}, "department": "IT Infrastructure", "role": "IT Specialist"}]

# The load() method does the inverse of the dump() method. It deserializes JSON from a file into basic Python objects. 
# The loads() method also deserializes JSON into basic Python objects, but parses a string instead of a file.
import json
with open('people.json', 'r') as people_json:
    people = json.load(people_json)
print(people)
[{'name': 'Sabrina Green', 'username': 'sgreen', 'phone': {'office': '802-867-5309', 'cell': '802-867-5310'}, 'department': 'IT Infrastructure', 'role': 'Systems Administrator'}, {'name': 'Eli Jones', 'username': 'ejones', 'phone': {'office': '684-348-1127'}, 'department': 'IT Infrastructure', 'role': 'IT Specialist'}, {'name': 'Melody Daniels', 'username': 'mdaniels', 'phone': {'cell': '846-687-7436'}, 'department': 'User Experience Research', 'role': 'Programmer'}, {'name': 'Charlie Rivera', 'username': 'riverac', 'phone': {'office': '698-746-3357'}, 'department': 'Development', 'role': 'Web Developer'}]

#----------------------------------------------------------------------------------------------------------------------------------------

YAML - Yet Another Markup Language
# YAML is used the most for storing configuration values

import yaml
with open('people.yaml', 'w') as people_yaml:
    yaml.safe_dump(original_object, yaml_object)

- department: IT Infrastructure
  name: Sabrina Green
  phone:
    cell: 802-867-5310
    office: 802-867-5309
  role: Systems Administrator
  username: sgreen
- department: IT Infrastructure
  name: Eli Jones
  phone:
    office: 684-348-1127
  role: IT Specialist
  username: ejones


#=============================================================================================================================================================
Data Streams

I/O Streams:     STDIN, STDOUT, STERROR

user_input = input("This text will be shown on screen to the user')       # input always returns a string; must be explicitely parsed to other data types
                                                                          # is input is read from a file (read_input.py < text_file.txt) the input is read until the
                                                                          # first newline character (\n)

Access Environment Variables in Python
import os
path = os.environ.get("PATH", "default_value") # could also be accessed via os.environ['PATH'], but the get-methon returns a default value if the value is not defined
                                                 # while accessing the non-existing value directly would return an error
import sys
sys.argv                                         # access arguments from the function call, returns a tuple
logfile = sys.argv[1]                            # argument 1 contains the logfile, e.g. bash:~$ ./run_python.py syslog
sys.exit(failure_code)                           # exit a program while returning a failure code
sys.stdin                                        # receives input from stdin (input_program.py < testfile.txt or by piping)
                                            
run bash functionality in Python
import subprocess                               # parent process is blocked while child process is executed
subprocess.run(['date'])                         # print actual date, equal to command date in bash
subprocess.run(['sleep', '2'])                   # called with two arguments (from 2nd parameter on: Command Line Arguments)

result = subprocess.run(['ls', 'unknown_file')]  # one bash command with one parameter throws an error
print(result.returncode)                         # returncode of child process made visible in python

result = subprocess.run(['host', '8.8.8.8'], capture_output=True)      # capture_output delivers output in result.stdout
print(result.returncode)                         # as already seen
print(result.stdout)                             # show output of child process in Python
                                                 # if output starts with b'' --> binary output (Python does not know which encoding to use)
                                                 # UTF-8 encoding: part of unicode standard that lists all possible characters that can be represented
print(result.stdout.decode())                    # convert binary format into given encoding, default: UTF-8
print(result.stdout.decode().split())            # split encoded output

result = subprocess.run(['rm', 'does_not_exist.py'], capture_output=True)     # throws an error; subprocess.run returns a CompletedProcess-object
print(result.returncode)                         # != 0
print(result.stdout)                             # b''
print(result.stderr)                             # b"failure message" (in binary code)


Process: Take environment variables, add / change them as needed and hand them over to the child process
import os
my_env = os.environ.copy()
my_env['PATH'] = os.pathsep.join(["/own/path/", my_env['PATH']])        # add own_path to enviroment variable, original environment is NOT changed
                                                                        # pathsep = path seperator
result = subprocess.run(["myapp"], env = my_env)

what can also be changed?
cwd      - set own current working directory
timeout  - set own timeout, e.g. if system hangs up
shell    - true, will first execute an instance of the system default shell and run the given command inside of it

#=============================================================================================================================================================
E-Mails

# defined by SMTP (Simple Mail Transfer Protocol) and MIME (Multipurpose Internet Mail Extensions) standards
# SMTP: This protocol specifies how computers can deliver email to each other.
# MIME: MIME standard is used to encode all sorts of files as text strings that can be sent via email. 
from email.message import EmailMessage
message = EmailMessage                      # create an empty Email
print(message)                              # printing the message object gives us the string representation of that object

# From, To, and Subject are examples of email header fields. They’re key-value pairs of labels and instructions 
# used by email clients and servers to route and display the email. They’re separate from the email's message body, 
# which is the main content of the message.

sender = "me@example.com"
recipient = "you@example.com"
message['From'] = sender
message['To'] = recipient
print(message)
# --> From: me@example.com
# --> To: you@example.com

message['Subject'] = 'Greetings from {} to {}!'.format(sender, recipient)
print(message)
# --> From: me@example.com
# --> To: you@example.com
# --> Subject: Greetings from me@example.com to you@example.com!

body = """Hey there!
...
I'm learning to send emails using Python!"""
message.set_content(body)
print(message)
# --> From: me@example.com
# --> To: you@example.com
# --> Subject: Greetings from me@example.com to you@example.com!
# --> MIME-Version: 1.0
# --> Content-Type: text/plain; charset="utf-8"
# --> Content-Transfer-Encoding: 7bit
# --> 
# --> Hey there!
# --> 
# --> I'm learning to send email using Python!

Attachments
# In order for the recipient of your message to understand what to do with an attachment, you  need to label the attachment 
# with a MIME type and subtype to tell them what sort of file you’re sending. The Internet Assigned Numbers Authority (IANA) 
# (iana.org) hosts a registry of valid MIME types. If you know the correct type and subtype of the files you’ll be sending, 
# you can use those values directly. If you don't know, you can use the Python mimetypes module to make a good guess!
import os.path
attachment_path = "/tmp/example.png"
attachment_filename = os.path.basename(attachment_path)
import mimetypes
mime_type, _ = mimetypes.guess_type(attachment_path)
print(mime_type)
# --> image/png
# mime_type string contains the MIME type and subtype, separated by a slash. The EmailMessage type needs a MIME type and 
# subtypes as separate strings, so let's split this up:
mime_type, mime_subtype = mime_type.split('/', 1)
# Let's add the attachment to our message:
with open(attachment_path, 'rb') as ap:
    message.add_attachment(ap.read(),
        maintype=mime_type,
        subtype=mime_subtype,
        filename=os.path.basename(attachment_path))
print(message)
# --> Content-Type: multipart/mixed; boundary="===============5350123048127315795=="
# --> 
# --> --===============5350123048127315795==
# --> Content-Type: text/plain; charset="utf-8"
# --> Content-Transfer-Encoding: 7bit
# --> 
# --> Hey there!
# --> 
# --> I'm learning to send email using Python!
# --> 
# --> --===============5350123048127315795==
# --> Content-Type: image/png
# --> Content-Transfer-Encoding: base64
# --> Content-Disposition: attachment; filename="example.png"
# --> MIME-Version: 1.0
# --> 
# --> iVBORw0KGgoAAAANSUhEUgAAASIAAABSCAYAAADw69nDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAg
# --> AElEQVR4nO2dd3wUZf7HP8/M9k2nKIJA4BCUNJKgNJWIBUUgEggCiSgeVhA8jzv05Gc5z4KHiqin
# --> eBZIIBDKIXggKIeCRCAhjQAqx4UiCARSt83uzDy/PzazTDZbwy4BnHde+9qZydNn97Pf5/uUIZRS

# The entire message can still be serialized as a text string, including the image that we attached! 
# The email message as a whole has the MIME type "multipart/mixed". Each part of the message has its own MIME type. 
# The message body is still there as a "text/plain" part, and the image attachment is a "image/png" part.

SENDING MAILS

import smtplib

# With smtplib, we'll create an object that will represent our mail server, and handle sending messages to that server.
# You can connect to a remote SMTP server using Transport Layer Security (TLS). An earlier version of the TLS protocol was 
# called Secure Sockets Layer (SSL), and you’ll sometimes see TLS and SSL used interchangeably. This SSL/TLS is the same protocol 
# that's used to add a secure transmission layer to HTTP, making it HTTPS. Within the smtplib, there are two classes for making 
# connections to an SMTP server: The SMTP class will make a direct SMTP connection, and the SMTP_SSL class will make a SMTP connection 
# over SSL/TLS. Like this:
mail_server = smtplib.SMTP_SSL('smtp.example.com')

# If you want to see the SMTP messages that are being sent back and forth by the smtplib module behind the scenes, you can set the debug 
# level on the SMTP or SMTP_SSL object.
mail_server.set_debuglevel(1)

# Now that we’ve made a connection to the SMTP server, the next thing we need to do is authenticate to the SMTP server. Typically, 
# email providers wants us to provide a username and password to connect. Let's put the password into a variable so it's not visible 
# on the screen.
import getpass
mail_pass = getpass.getpass('Password? ')
# --> Password?
# now the Password must be entered...
# The Password is not displayed during input, but Watch out, the mail_pass variable is still just an ordinary string!

# authenticate to the email server using the SMTP object's login method.
mail_server.login(sender, mail_pass)
# --> (235, b'2.7.0 Accepted')

# If the login attempt succeeds, the login method will return a tuple of the SMTP status code and a message explaining the 
# reason for the status. If the login attempt fails, the module will raise a SMTPAuthenticationError exception.

# Send message!
mail_server.send_message(message)
# Close connection to mail-server
mail_server.quit()

#=============================================================================================================================================================
PDFs

from reportlab.platypus import SimpleDocTemplate
report = SimpleDocTemplate("/tmp/report.pdf")

# Flowables         are sort of like chunks of a document that reportlab can arrange to make a complete report
from reportlab.platypus import Paragraph, Spacer, Table, Image        # these are Flowables

# We have to tell reportlab what style we want each part of the document to have, so let's import some more things 
# from the module to describe style
from reportlab.lib.styles import getSampleStyleSheet
styles = getSampleStyleSheet()
# You can make a style all of your own, but we’ll use the default provided by the module for these examples. 

report_title = Paragraph("A Complete Inventory of My Fruit", styles["h1"])

# generate report out of a list of flowables
report.build([report_title])

# add Table (data is contained in a list of lists)
from reportlab.lib import colors
table_style = [('GRID', (0,0), (-1,-1), 1, colors.black)]
report_table = Table(data=[[1st_line, 1st_value],[2nd_line, 2nd_value],[3rd_line, 3rd_value]], style=table_style, hAlign="LEFT")
report.build([report_title, report_table])

# add Graphics
from reportlab.graphics.shapes import Drawing         # Drawing is a Flowable
from reportlab.graphics.charts.piecharts import Pie   # Pie is not a Flowable but can be placed in Flowable "Drawing"
report_pie = Pie(width=3*inch, height=3*inch)

# To add data to our Pie chart, we need two separate lists: One for data, and one for labels. 
report_pie.data = [value1, value2, value3]
report_pie.labels = [label1, label2, label3]

report.build([report_title, report_table, report_chart])

#=============================================================================================================================================================
Error Handling

try:
    f = open(filename)
except OSError:
    return None
    
# raising own errors
if not wanted_condition:
    raise ValueError('descriptive error message')
    
#=============================================================================================================================================================
HTTP-requests

import requests                             # python module to
                                            #   - find the web server, 
                                            #   - make a network connection, 
                                            #   - construct an HTTP message, 
                                            #   - wait for a response, or
                                            #   - decode the response
response = requests.get('url')   

# e.g. 
response = requests.get('www.google.com')
print(response.text[:300])                  # print first 300 characters of response
# --> <!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="de"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script nonce="dZfbIAn803LDGXS9
# response contains HTML webpage content

# requests already unzipped the response
# see raw response
response = requests.get('www.google.com', stream=True)
print(response.raw.read()[:100])
# --> b'\x1f\x8b\x08\x00\x00\x00\x00\x00\x02\xff\xc5Z\xdbz\x9b\xc8\x96\xbe\xcfS`\xf2\xb5-\xc6X\x02$t\xc28\xe3v\xdc\xdd\xee\xce\xa9\xb7\xdd;\xe9\x9d\xce\xf6W@\t\x88\x11`@>D\xd6\x9b\xce\xe5<\xc3\\\xcd\xc5\xfc\xab8\x08\xc9Nz\x1f.&\x8e1U\xb5j\xd5:\xfc\xb5jU\x15\x87;^\xe2\x16\xf7)\x97\x82b\x1e\x1d\x1d\xd2S'
response.request.headers['Accept-Encoding']
# --> 'gzip, deflate'
response.headers['Content-Encoding']
# --> 'gzip'

# How to find out if the request was successfull
response.ok                     # True
response.status_code            # 200
# Use requests module to raise an HTTPError if response was not successfull
response.raise_for_status()

# HTTP GET and POST Methods
HTTP methods:
    - GET:      retrieves or gets the resource specified in the URL
    - POST:     sends, or posts, data to a web service      
    - PUT
    - DELETE

# A GET request can have parameters.
https://example.com/path/to/api/cat_pictures?search=grey+kitten&max_results=15
                                            ? The question mark separates the URL resource from the resource's parameters
                                              These parameters are one or more key-value pairs, formatted as a query string
                                                               & Combines different parameters

# use requests.get to hand over parameters more comfortably
p = {"search": "grey kitten",
     "max_results": 15}
response = requests.get("https://example.com/path/to/api", params=p)
response.request.url
# --> 'https://example.com/path/to/api?search=grey+kitten&max_results=15'

# In the a.m. cases we perform a get requests but also send data (the parameters) to a web service
# You can also use the POST method which tends to be used when there's a bunch of data to transmit.

# A POST request looks very similar to a GET request. Instead of setting the params attribute, which gets turned into a query 
# string and appended to the URL, we use the data attribute, which contains the data that will be sent as part of the POST request.
p = {"description": "white kitten",
     "name": "Snowball",
     "age_months": 6}
response = requests.post("https://example.com/path/to/api", data=p)
response.request.url
# --> 'https://example.com/path/to/api'
# url is much simpler now, the parameters went into the body of the HTTP message
response.request.body
# --> 'description=white+kitten&name=Snowball&age_months=6'

# or use JSON
p = {"description": "white kitten",
     "name": "Snowball",
     "age_months": 6}
response = requests.post("https://example.com/path/to/api", json=p)
response.request.url
# --> 'https://example.com/path/to/api'
response.request.body
# --> b'{"description": "white kitten", "name": "Snowball", "age_months": 6}'


#=============================================================================================================================================================

Testing

Automated Testg :        Automate Process of checking if the returned value matches the expectations
                         Test Cases are built automatically

Unit Tests:              Type of Automated Testing
                         Used to verify that small, isolated parts of a program are correct
                         Test should never modify the production environment; if the environment is needed tests run in a test environment


Edge cases:               Inputs to our code that produce unexpected results, and are found at the extreme ends of the ranges of input we 
                          imagine our programs will typically work with
                          
White-box testing         also sometimes called clear-box or transparent testing relies on the test creators knowledge of the software being 
                          tested to construct the test cases.

black-box testing         the software being tested is treated like an opaque (undurchsichtig) box. Black-box tests are written with an 
                          awareness of what the program is supposed to do, its requirements or specifications, but not how it does it.

test script.py with a seperate script, e.g. script_test.py ----------------------------------------------------------------------

>> script_test.py
#! ...
from script import function_to_test
import unittest                        # Python module for testing

class TestFunctionToTest(unittest.TestCase):        # write own test function that inherits from unittest class
 
# assertEqual
    def test_case_1(self):                          # function name must start with "test" to be taken into account by the unittest module
        testcase = "testcase for function_to_test"
        expected = "expected return value from function to test"
        self.assertEqual(function_to_test(testcase), expected)      # assertEqual is inherited from TestCase class
        
# assert                                                      # depending on the state of the program an error is raised
                                                              # throws an Assertion Error
assert type(username) == str, "username must be a string"     # also helpful for debugging

# assertRaises                                                  # checks if an error is raised
self.assertRaises(ValueError, function_to_test, para1, para2)   # checks if a ValueError is raised with given para1 and para2

        
unittest.main()  # start Test

------------------------------------------------------------------------------------------------------------------------------------

Integration Tests:        after units are tested here the all-in-all is tested
                          is maybe performed in own test environment
                          interactivity between different modules is tested
                          Verifying an automation script works well with the overall system and external entities

Regression Tests:         test is performed, bug is fixed, test is re-performed and checked that the bug is gone
                          A test that is written after a bug has been identified in order to ensure the bug doesn't show up again later is called Reg. Test

Smoke Tests               or build verification tests
                          Does the program run? Comes from hardware development (if there is smoke there is fire!)
                          This test finds out if the program can run in its basic form before undergoing more refined test cases.
                          
Load tests                Scripts performs well if there is a high load on the system
                          type of software testing used to verify the software’s ability to behave well under significantly stressed testing conditions

Test suite                Many tests that work together, a suite of tests

Test-Driven Development:  TDD
                          First: create Tests, that later code shall succeed; Then: write the code
                          
Continuous Integration:   When engineers submit their code, it's integrated into the main repository and tests are automatically run 
                          against it to spot bugs and errors in a process called Continuous Integration. 
                          Although useful, setting up a continuous integration process can be a big undertaking.





#=============================================================================================================================================================

Bash commands

globs
*
?

basename          # basename filename extension (e.g. basename index.HTM HTM) returns filename without extension
bg                # causes a job that was stopped to go to the background
cat               # show files
cd                # change dir
chmod             # change permissions on file
cronjobs          # schedule based scripts on UNIX operating systems
curl              # access urls from the command line
cut               # for each line in the given file, splits the line according to the given separator and prints the given fields (starting from 1)
    cut -d seperator -f fields       ! seperator: -d 5 (just keeps field 5), -d -5 (keeps all fields from 1 to 5), -d 1-2 (keeps fields 1 and 2)
                                     !            -d 1,3 (keeps fields 1 and 3), -d 5- (keeps all fields from 5 to end): ranges: a - b,  - b, a -
date              # prints the current date
echo              # print 
   echo $?            # print info on $-variable which contains the error messega (0 - success, > 0 - error)
env               # show environment variables
export            # create new environment variable and make it visible to all processes, e.g. export ENV_VARIABLE=env_var_to_set
fg                # causes a job that was stopped or in the background to return to the foreground
file              # prints type of given file
free              # shows the amount of unused memory on the current system
head              # prints first ten lines
host              # return name to given ip address
jobs: lists the jobs currently running or stopped
    jobs -l       - gives the output of list as a list
less              # terminal paging program
ls                # list contents of a directory
ls -l

permissions        number of inodes           owner     group     size of     last date of     name
user group all     that point to the file        of the file      file        modification

netstat           # to find which processes are listening on which ports, we'll be using the netstat command, which returns 
                  #  network-related information
ps                # list all currently running processes
    ps ax             # list all currently running processes in the running computer
    ps e              # shows the environment for the processes listed
pwd               # print working directory
rm                # remove file(s)
sort              # sort -n (sort numerically], -r (sort reverse)
systemctl         # a utility for controlling the systemd system and service manager. It comes with a long list of options for 
                  #     different functionality, including starting, stopping, restarting, or reloading a daemon.
tail              # show last 10 lines
test              # evaluates the conditions received and exits with zero when they are true and with one when they're false
    test -e           # tests if a file exists
    test -n           # tests if a string variable is empty or not
top               # shows the processes currently using the most CPU time (press "q" to quit) 
tr                # translate first arg to second arg: tr ' ' '\n' -> replace all spaces by newlines
uniq              # displays each match once, uniq -c prefixes each line with number of times the match occurred
uptime            # shows how long the computer has been running
wc                # counts number of words, lines, ...
who               # prints the user who is currently logged in
                  # prints the list of users currently logged into the computer



output streams
0>      STDIN stream
1>      STDOUT stream
2>      STDERR stream       # 2: file descriptor of the STDERR stream


Signals: Tokens delivered to running processes to indicate a desired action
Ctrl-C                  SIGINT (Program is finished cleanly)
Ctrl-Z                  SIGSTOP (Program is stopped), restart program with 'fg'
kill                    SIGTERM (terminate program)
                        needs PID (process identifier) to address the program which shall be killed
                        
ps: lists the processes executing in the current terminal for the current user
ps ax: lists all processes currently executing for all users  
ps e: shows the environment for the processes listed  
kill PID: sends the SIGTERM signal to the process identified by PID
fg: causes a job that was stopped or in the background to return to the foreground
bg: causes a job that was stopped to go to the background
jobs: lists the jobs currently running or stopped

top: shows the processes currently using the most CPU time (press "q" to quit)

#=============================================================================================================================================================

Bash Scripting

#!/bin/bash

var=value                                         # no spaces allowed here!
export var_valid_of_program_code='other value'    # define a variable that is also valid in bash
echo $var                                         # adress variable with $

!arguments-------------------------------------------------------------------------------------------------------
argument1=$1                         # access the first command line argument



! conditionals: use exit status of funtion calls in bash---------------------------------------------------------
! in bash scripting an exit value of 0 means success
! also use "test" command in bash to check a certain condition to be true/false

if grep 127.0.0.1 /etc/hosts; then         ! uses the exit status of the grep command, not the output of the grep command
                                           ! but the outuput of the bash command will be written to the screen
    echo "Everything OK"                   ! after the grep output, the conditional echo is displayed
else
    echo 'Error'
fi

if test -n "$PATH"; then ...; fi           ! test -n    tests if a string variable is empty or not
! can also be written as
if [ -n "$PATH" ]; then ...; fi             ! [ is an alias for test command; there needs to be a space before the closing bracket
----------------------------------------------------------------------------------------------------
WHILE-LOOP

n=1
while [ $n -le 5 ]; do
    ...
    ((n+=1))                     ! bash construct of double parentheses that lets us do arithemetic operations with our variables
done

n=1
command=$1
while ! command && [ $n -le 5 ]; do   ! command shall stand for a command that can be 0 (true) or >0 (false)
                                        ! while loop will be executed as long as command is not true OR as long as n <= 5
                                        ! or if the command fails we will retry to execute the command five times
    sleep $n                          ! to give the system time before retrying the command, the system will sleep (shortly at beginning, then longer)
    ((n+1))
done
-----------------------------------------------------------------------------------------------------
FOR-LOOP

for fruit in apple orange banana; do          # list is seperated by spaces
    echo "I like $fruit!"
done

! rename file HTM -> html
for  file in *.HTM; do
    name=$(basename "$file" .HTM)              !  $file is surrounded by "" so the command will work, even if the filename has spaces within
    mv "$file" "$name.html"                    ! for testing use echo: 'echo mv "$file" "$name.html"' to see what the script will do
done

--------------------------------------------------------------------------------------------------
/var/log/syslog                         ! Position of System logfile !

tail /var/log/syslog                             ! show last 10 lines of system log-file to get to know the structure of it
tail /var/log/syslog  | cut -d' ' -f5-           ! split line with spaces ( -d' ') and print field no. 5 and everything that comes after it (-f5-)

cut -d' ' -f5- /var/log/syslog | sort | uniq -c | sort -nr | head
                                                 ! find out which process message occur most often
                                                 
#=============================================================================================================================================================
Django

full-stack web framework
A full-stack web framework handles a bunch of different components that are typical when creating a web application. 
It contains libraries that help you handle each of the pieces: 
    - writing your application's code, 
    - storing and retrieving data, 
    - receiving web requests, and 
    - responding to them

Web frameworks are commonly split into three basic components: 
    (1) the application code, where you'll add all of your application's logic; 
    (2) the data storage, where you'll configure what data you want to store and how you're storing it; and 
    (3) the web server, where you'll state which pages are served by which logic.

Splitting your code like that helps you write more modular code, promotes code reuse, and allows for flexibility 
when viewing and accessing data. 
For example, 
    you could have a simple web page where users of the system can access the information already stored in it, and 
    a separate programmatic interface that can be used by other scripts or applications to transmit data to the system.

urlresolver module:         core module in Django that interprets URL requests and matches them against a list of defined patterns
view:                       If a URL matches a pattern, the request is passed to the associated function, called a view

Django can also handle reading and writing data from a database.
object-relational mapper (ORM): This tool provides an easy mapping between data models defined as Python classes and an 
                                underlying database that stores the data in question.
