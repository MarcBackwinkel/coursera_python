Steps for coding Projects.

    1. Understand the problem statement
    2. Research
    3. Planning
    4. Writing / Testing
    
#=============================================================================================================================================================
# Modules in Python

pip install module_name

Importing Modules:
import json
from re import L
from subprocess import CREATE_DEFAULT_ERROR_MODE
import module      # when module is imported, __init__.py is read

import module sys               # The sys module provides information about the Python interpreter's constants, functions, and methods. 
import module os                # The os module provides a portable way of using operating system dependent functionality with Python.

module: requests                # module for http-requests
import requests
response = requests.get("http://www.google.com")
print(response.text)

module: datetime                 # convert between different time formats

module: arrow                      # date handling
date = arrow.get('2022-08-10', 'YYYY-MM-DD')     # parse string to date
date.shift(weeks=+6).format('MMM DD YYYY')   # add 4 weeks to date and 
                                                                                     # format output
 
module: pil                             # python image library
image = PIL.Image.open('picture.jpg')
print(image.size, image.format)

module: shutil                        # system health
du = shutil.disk_usage('/')
module: psutil                        # performance monitoring
psutil.cpu_percent(0.1)


Running python-modules on Linux
use shebang: #!/usr/bin/env python3
chmod +x                             # mark script as executable
./script.py


Working with Files
file = open("file.txt","w")        # second parameter: r -> read mode (default), w -> write only mode, a -> append, r+ -> read-write mode
                                    # if file is opened for writing and it already exists, the old contents are deleted as soon as the file is opened
file.readline()                    # reads file line by line, puts an \n automatically to the end <-- can be removed with strip()
file.read()                        # reads file till the end
lines = file.readlines()           # reads all lines of a file and returns them as list
file.write("text")                 # returns number of characters that were written
file.close()
or
with open("file.txt") as file:      # with automatically closes file after with block is left
    print(file.readline())
    
    
Working with the file system
import os
os.getcwd()                            # get current working directory
os.listdir("dir")                      # returns a list of all files in the directory
path = os.path.join("dir", "file.txt") # combines directory and file name os independently
os.path.isdir("is_this_a_dir")         # check if parameter is a directory, eventually combine name with os.path.join("dir", "file.txt")
os.mkdir("new_dir")
os.rmdir("dir_to_remove")              # will only remove a directory if the directory is empty
os.chdir("new_dir")
os.path.exists("filename.txt")         # check if a file exists, returns True / False
os.path.getsize("filename.txt")        # filesize
ts = os.path.getmtime("filename.tx")   # last timestamp of modification; timestamp in milliseconds
    datetime.datetime.fromtimestamp(ts) # format timestamp as actual date / attention: previously import datetime-module!    
abs_path = os.path.abspath("file.txt") # returns absolute path to file
os.remove("file_to_be_deleted.txt")    # remove file
os.rename("old_name.txt", "new_name.txt")


csv-Files
import csv
f = open("csv_file.txt")                # use attributes w and a to write to csv-file
csv_f = csv.reader(f)
for row in csv_f:                     # read csv-file
    col1, col2, col3 = row              # unpack values, col1 == row[0]
    
with open('file.csv', 'w') as file_csv:  # write to a csv-file with a list
    writer = csv.writer(file_csv)
    writer.writerow([value1, value2, value3])    # writes a single row to a csv file
    writer.writerows([[value1, value2, value3], [value4, value5, value6]])     # write list of lists to a csv file 
    
with open('file.csv') as file_csv:  # read csv-file into a dict
    reader = csv.DictReader(file_csv)     # reads a file into a dict, using first row as keys
    
with open('file.csv', 'w') as file_csv:  # write to csv-file using a dict
    writer = csv.DictWriter(file_csv, fieldnames=keys)     # keys is a list of the key names
    writer.writeheader()
    writer.writerows(dict)               # dict is a dictionary, which keys are identical to the list-variable keys
    
#=============================================================================================================================================================

Regular Expressions

RegEx
.      matches any character (wildcard)
^      position must match the beginning
$      position must match the end
()     capturing group
[]     define a range, e.g. [pP], [a-z], [a-zA-Z0-9], [.,:;?!]
[^]    define a range which is excluded [^a-zA-Z ] (exclude any letter - case insensitive - and space)
|      separate words to find
repeated match qualifiers
*      match any number of chars incl. zero times; it works "greedy" (matches as many characters as possible)
+      match any number of chars at least one time; it works "greedy" (matches as many characters as possible)
?      character before is optional, like p? or [a-z]?
{}     numeric repetition qualifiers, e.g. {5}, {1,5}
Escpaing characters
.*+?^$[]{}
Special Sequences
\b     word boundaries, e.g. r'\b[a-zA-Z]{5}\b' all words with exactly 5 characters
\d     digits
\s     whitespace characters (like space, tab, newline \n
\w     any alphanumeric character (incl. letters, numbers, underscores)

import re
result = re.search(r'regex_as_string', text_to_be_looked_at)    # r -> Rawstring shall not be interpreted by Python but shall be handed to the function as is
                                                                # if Rawstring is a pure text string, then the 'r' would not be needed
                                                                # but: Always use Rawstrings for regular expressions in Python!!!
                                                                # result is a re.Match object <; span, match = matching_string>; if nothing is found None is returned
                                                                # re.Match object is a tuple, [0]: all results, [1]: first group, [2]: second group, ...
                                                                         # groups are built acc. to parenthesis in reg ex-string, e.g. r'(\w+), (\w+)' 
re.search(r'regex', text, re.IGNORECASE())  # search case insensitive
re.findall(r'regex', text)                  # find all matches, returns a list with all results
re.split(r'regex', text)                    # splits a text into different strings using regex
re.sub(r'regex', new_text, text)            # replaces regex-strings in text by new_text
                                            # new_text may also be a regex, e.g. to access captured groups: r'\2 \1' (second_group first_group)

bash-Commands
grep
-i  : search case insensitive
egrep                                       # also supports + and ? as repeated match qualifiers 

#=============================================================================================================================================================
Data Serialization

JSON - Javascript Object Notation
# JSON is used frequently for transmitting data between web services

import json
with open('people.json', 'w') as people_json:
    json.dump(original_object, json_object, indent=4)   # serializes original object --> json format 

[
    {
        "att11": "value11",
        "att12": "value12",
        {
            "dict_att11": "dict_value11",
            "dict_att12": "dict_value12"
        }
    },
    {
        "att21": "value21",
        "att22": "value22",
        {
            "dict_att21": "dict_value21",
            "dict_att22": "dict_value22"
        }
    },
    {
        ...
    }
]

# JSON has strings, which are enclosed in quotes                                    "string"
# JSON has integers                                                                 42
# JSON has objects, which are key-value pair structures like Python dictionaries    {
                                                                                      "name": "Sabrina Green",
                                                                                      "username": "sgreen",
                                                                                      "uid": 1002
                                                                                    }
# And a key-value pair can contain another object as a value. 
# JSON has arrays, which are equivalent to Python lists. Arrays can contain strings, numbers, objects, or other arrays.  
                                                                                    [
                                                                                      "apple",
                                                                                      "banana",
                                                                                      12345,
                                                                                      67890,
                                                                                      {
                                                                                        "name": "Sabrina Green",
                                                                                        "username": "sgreen",
                                                                                        "phone": {
                                                                                        "office": "802-867-5309",
                                                                                        "cell": "802-867-5310"
                                                                                        },
                                                                                        "department": "IT Infrastructure",
                                                                                        "role": "Systems Administrator"
                                                                                      }
                                                                                    ]

# json-File:
import json

people = [
  {
    "name": "Sabrina Green",
    "username": "sgreen",
    "phone": {
      "office": "802-867-5309",
      "cell": "802-867-5310"
    },
    "department": "IT Infrastructure",
    "role": "Systems Administrator"
  },
  {
    "name": "Eli Jones",
    "username": "ejones",
    "phone": {
      "office": "684-348-1127"
    },
    "department": "IT Infrastructure",
    "role": "IT Specialist"
  }
]

with open('people.json', 'w') as people_json:
    json.dump(people, people_json)

# json-dump people_json:
[{"name": "Sabrina Green", "username": "sgreen", "phone": {"office": "802-867-5309", "cell": "802-867-5310"}, "department": "IT Infrastructure", "role": "Systems Administrator"}, {"name": "Eli Jones", "username": "ejones", "phone": {"office": "684-348-1127"}, "department": "IT Infrastructure", "role": "IT Specialist"}]

# use indent-parameter to make it more readable:
with open('people.json', 'w') as people_json:
    json.dump(people, people_json, indent=2)

# resulting file:
[
  {
    "name": "Sabrina Green",
    "username": "sgreen",
    "phone": {
      "office": "802-867-5309",
      "cell": "802-867-5310"
    },
    "department": "IT Infrastructure",
    "role": "Systems Administrator"
  },
  {
    "name": "Eli Jones",
    "username": "ejones",
    "phone": {
      "office": "684-348-1127"
    },
    "department": "IT Infrastructure",
    "role": "IT Specialist"
  }
]

# Another option is to use the dumps() method, which also serializes Python objects, 
# but returns a string instead of writing directly to a file. 
people_json = json.dumps(people)
print(people_json)
[{"name": "Sabrina Green", "username": "sgreen", "phone": {"office": "802-867-5309", "cell": "802-867-5310"}, "department": "IT Infrastructure", "role": "Systems Administrator"}, {"name": "Eli Jones", "username": "ejones", "phone": {"office": "684-348-1127"}, "department": "IT Infrastructure", "role": "IT Specialist"}]

# The load() method does the inverse of the dump() method. It deserializes JSON from a file into basic Python objects. 
# The loads() method also deserializes JSON into basic Python objects, but parses a string instead of a file.
import json
with open('people.json', 'r') as people_json:
    people = json.load(people_json)
print(people)
[{'name': 'Sabrina Green', 'username': 'sgreen', 'phone': {'office': '802-867-5309', 'cell': '802-867-5310'}, 'department': 'IT Infrastructure', 'role': 'Systems Administrator'}, {'name': 'Eli Jones', 'username': 'ejones', 'phone': {'office': '684-348-1127'}, 'department': 'IT Infrastructure', 'role': 'IT Specialist'}, {'name': 'Melody Daniels', 'username': 'mdaniels', 'phone': {'cell': '846-687-7436'}, 'department': 'User Experience Research', 'role': 'Programmer'}, {'name': 'Charlie Rivera', 'username': 'riverac', 'phone': {'office': '698-746-3357'}, 'department': 'Development', 'role': 'Web Developer'}]

#----------------------------------------------------------------------------------------------------------------------------------------

YAML - Yet Another Markup Language
# YAML is used the most for storing configuration values

import yaml
with open('people.yaml', 'w') as people_yaml:
    yaml.safe_dump(original_object, yaml_object)

- department: IT Infrastructure
  name: Sabrina Green
  phone:
    cell: 802-867-5310
    office: 802-867-5309
  role: Systems Administrator
  username: sgreen
- department: IT Infrastructure
  name: Eli Jones
  phone:
    office: 684-348-1127
  role: IT Specialist
  username: ejones


#=============================================================================================================================================================

Data Streams

I/O Streams:     STDIN, STDOUT, STERROR

user_input = input("This text will be shown on screen to the user')       # input always returns a string; must be explicitely parsed to other data types
                                                                          # is input is read from a file (read_input.py < text_file.txt) the input is read until the
                                                                          # first newline character (\n)

Access Environment Variables in Python
import os
path = os.environ.get("PATH", "default_value") # could also be accessed via os.environ['PATH'], but the get-methon returns a default value if the value is not defined
                                                 # while accessing the non-existing value directly would return an error
import sys
sys.argv                                         # access arguments from the function call, returns a tuple
logfile = sys.argv[1]                            # argument 1 contains the logfile, e.g. bash:~$ ./run_python.py syslog
sys.exit(failure_code)                           # exit a program while returning a failure code
sys.stdin                                        # receives input from stdin (input_program.py < testfile.txt or by piping)
                                            
run bash functionality in Python
import subprocess                               # parent process is blocked while child process is executed
subprocess.run(['date'])                         # print actual date, equal to command date in bash
subprocess.run(['sleep', '2'])                   # called with two arguments (from 2nd parameter on: Command Line Arguments)

result = subprocess.run(['ls', 'unknown_file')]  # one bash command with one parameter throws an error
print(result.returncode)                         # returncode of child process made visible in python

result = subprocess.run(['host', '8.8.8.8'], capture_output=True)      # capture_output delivers output in result.stdout
print(result.returncode)                         # as already seen
print(result.stdout)                             # show output of child process in Python
                                                 # if output starts with b'' --> binary output (Python does not know which encoding to use)
                                                 # UTF-8 encoding: part of unicode standard that lists all possible characters that can be represented
print(result.stdout.decode())                    # convert binary format into given encoding, default: UTF-8
print(result.stdout.decode().split())            # split encoded output

result = subprocess.run(['rm', 'does_not_exist.py'], capture_output=True)     # throws an error; subprocess.run returns a CompletedProcess-object
print(result.returncode)                         # != 0
print(result.stdout)                             # b''
print(result.stderr)                             # b"failure message" (in binary code)


Process: Take environment variables, add / change them as needed and hand them over to the child process
import os
my_env = os.environ.copy()
my_env['PATH'] = os.pathsep.join(["/own/path/", my_env['PATH']])        # add own_path to enviroment variable, original environment is NOT changed
                                                                        # pathsep = path seperator
result = subprocess.run(["myapp"], env = my_env)

what can also be changed?
cwd      - set own current working directory
timeout  - set own timeout, e.g. if system hangs up
shell    - true, will first execute an instance of the system default shell and run the given command inside of it

#=============================================================================================================================================================

Error Handling

try:
    f = open(filename)
except OSError:
    return None
    
# raising own errors
if not wanted_condition:
    raise ValueError('descriptive error message')
    


#=============================================================================================================================================================

Testing

Automated Testg :        Automate Process of checking if the returned value matches the expectations
                         Test Cases are built automatically

Unit Tests:              Type of Automated Testing
                         Used to verify that small, isolated parts of a program are correct
                         Test should never modify the production environment; if the environment is needed tests run in a test environment


Edge cases:               Inputs to our code that produce unexpected results, and are found at the extreme ends of the ranges of input we 
                          imagine our programs will typically work with
                          
White-box testing         also sometimes called clear-box or transparent testing relies on the test creators knowledge of the software being 
                          tested to construct the test cases.

black-box testing         the software being tested is treated like an opaque (undurchsichtig) box. Black-box tests are written with an 
                          awareness of what the program is supposed to do, its requirements or specifications, but not how it does it.

test script.py with a seperate script, e.g. script_test.py ----------------------------------------------------------------------

>> script_test.py
#! ...
from script import function_to_test
import unittest                        # Python module for testing

class TestFunctionToTest(unittest.TestCase):        # write own test function that inherits from unittest class
 
# assertEqual
    def test_case_1(self):                          # function name must start with "test" to be taken into account by the unittest module
        testcase = "testcase for function_to_test"
        expected = "expected return value from function to test"
        self.assertEqual(function_to_test(testcase), expected)      # assertEqual is inherited from TestCase class
        
# assert                                                      # depending on the state of the program an error is raised
                                                              # throws an Assertion Error
assert type(username) == str, "username must be a string"     # also helpful for debugging

# assertRaises                                                  # checks if an error is raised
self.assertRaises(ValueError, function_to_test, para1, para2)   # checks if a ValueError is raised with given para1 and para2

        
unittest.main()  # start Test

------------------------------------------------------------------------------------------------------------------------------------

Integration Tests:        after units are tested here the all-in-all is tested
                          is maybe performed in own test environment
                          interactivity between different modules is tested
                          Verifying an automation script works well with the overall system and external entities

Regression Tests:         test is performed, bug is fixed, test is re-performed and checked that the bug is gone
                          A test that is written after a bug has been identified in order to ensure the bug doesn't show up again later is called Reg. Test

Smoke Tests               or build verification tests
                          Does the program run? Comes from hardware development (if there is smoke there is fire!)
                          This test finds out if the program can run in its basic form before undergoing more refined test cases.
                          
Load tests                Scripts performs well if there is a high load on the system
                          type of software testing used to verify the softwareâ€™s ability to behave well under significantly stressed testing conditions

Test suite                Many tests that work together, a suite of tests

Test-Driven Development:  TDD
                          First: create Tests, that later code shall succeed; Then: write the code
                          
Continuous Integration:   When engineers submit their code, it's integrated into the main repository and tests are automatically run 
                          against it to spot bugs and errors in a process called Continuous Integration. 
                          Although useful, setting up a continuous integration process can be a big undertaking.





#=============================================================================================================================================================

Bash commands

globs
*
?

basename          # basename filename extension (e.g. basename index.HTM HTM) returns filename without extension
bg                # causes a job that was stopped to go to the background
cat               # show files
cd                # change dir
chmod             # change permissions on file
cronjobs          # schedule based scripts on UNIX operating systems
curl              # access urls from the command line
cut               # for each line in the given file, splits the line according to the given separator and prints the given fields (starting from 1)
    cut -d seperator -f fields       ! seperator: -d 5 (just keeps field 5), -d -5 (keeps all fields from 1 to 5), -d 1-2 (keeps fields 1 and 2)
                                     !            -d 1,3 (keeps fields 1 and 3), -d 5- (keeps all fields from 5 to end): ranges: a - b,  - b, a -
date              # prints the current date
echo              # print 
   echo $?            # print info on $-variable which contains the error messega (0 - success, > 0 - error)
env               # show environment variables
export            # create new environment variable and make it visible to all processes, e.g. export ENV_VARIABLE=env_var_to_set
fg                # causes a job that was stopped or in the background to return to the foreground
file              # prints type of given file
free              # shows the amount of unused memory on the current system
head              # prints first ten lines
host              # return name to given ip address
jobs: lists the jobs currently running or stopped
    jobs -l       - gives the output of list as a list
less              # terminal paging program
ls                # list contents of a directory
ls -l

permissions        number of inodes           owner     group     size of     last date of     name
user group all     that point to the file        of the file      file        modification

netstat           # to find which processes are listening on which ports, we'll be using the netstat command, which returns 
                  #  network-related information
ps                # list all currently running processes
    ps ax             # list all currently running processes in the running computer
    ps e              # shows the environment for the processes listed
pwd               # print working directory
rm                # remove file(s)
sort              # sort -n (sort numerically], -r (sort reverse)
systemctl         # a utility for controlling the systemd system and service manager. It comes with a long list of options for 
                  #     different functionality, including starting, stopping, restarting, or reloading a daemon.
tail              # show last 10 lines
test              # evaluates the conditions received and exits with zero when they are true and with one when they're false
    test -e           # tests if a file exists
    test -n           # tests if a string variable is empty or not
top               # shows the processes currently using the most CPU time (press "q" to quit) 
tr                # translate first arg to second arg: tr ' ' '\n' -> replace all spaces by newlines
uniq              # displays each match once, uniq -c prefixes each line with number of times the match occurred
uptime            # shows how long the computer has been running
wc                # counts number of words, lines, ...
who               # prints the user who is currently logged in
                  # prints the list of users currently logged into the computer



output streams
0>      STDIN stream
1>      STDOUT stream
2>      STDERR stream       # 2: file descriptor of the STDERR stream


Signals: Tokens delivered to running processes to indicate a desired action
Ctrl-C                  SIGINT (Program is finished cleanly)
Ctrl-Z                  SIGSTOP (Program is stopped), restart program with 'fg'
kill                    SIGTERM (terminate program)
                        needs PID (process identifier) to address the program which shall be killed
                        
ps: lists the processes executing in the current terminal for the current user
ps ax: lists all processes currently executing for all users  
ps e: shows the environment for the processes listed  
kill PID: sends the SIGTERM signal to the process identified by PID
fg: causes a job that was stopped or in the background to return to the foreground
bg: causes a job that was stopped to go to the background
jobs: lists the jobs currently running or stopped

top: shows the processes currently using the most CPU time (press "q" to quit)

#=============================================================================================================================================================

Bash Scripting

#!/bin/bash

var=value                                         # no spaces allowed here!
export var_valid_of_program_code='other value'    # define a variable that is also valid in bash
echo $var                                         # adress variable with $

!arguments-------------------------------------------------------------------------------------------------------
argument1=$1                         # access the first command line argument



! conditionals: use exit status of funtion calls in bash---------------------------------------------------------
! in bash scripting an exit value of 0 means success
! also use "test" command in bash to check a certain condition to be true/false

if grep 127.0.0.1 /etc/hosts; then         ! uses the exit status of the grep command, not the output of the grep command
                                           ! but the outuput of the bash command will be written to the screen
    echo "Everything OK"                   ! after the grep output, the conditional echo is displayed
else
    echo 'Error'
fi

if test -n "$PATH"; then ...; fi           ! test -n    tests if a string variable is empty or not
! can also be written as
if [ -n "$PATH" ]; then ...; fi             ! [ is an alias for test command; there needs to be a space before the closing bracket
----------------------------------------------------------------------------------------------------
WHILE-LOOP

n=1
while [ $n -le 5 ]; do
    ...
    ((n+=1))                     ! bash construct of double parentheses that lets us do arithemetic operations with our variables
done

n=1
command=$1
while ! command && [ $n -le 5 ]; do   ! command shall stand for a command that can be 0 (true) or >0 (false)
                                        ! while loop will be executed as long as command is not true OR as long as n <= 5
                                        ! or if the command fails we will retry to execute the command five times
    sleep $n                          ! to give the system time before retrying the command, the system will sleep (shortly at beginning, then longer)
    ((n+1))
done
-----------------------------------------------------------------------------------------------------
FOR-LOOP

for fruit in apple orange banana; do          # list is seperated by spaces
    echo "I like $fruit!"
done

! rename file HTM -> html
for  file in *.HTM; do
    name=$(basename "$file" .HTM)              !  $file is surrounded by "" so the command will work, even if the filename has spaces within
    mv "$file" "$name.html"                    ! for testing use echo: 'echo mv "$file" "$name.html"' to see what the script will do
done

--------------------------------------------------------------------------------------------------
/var/log/syslog                         ! Position of System logfile !

tail /var/log/syslog                             ! show last 10 lines of system log-file to get to know the structure of it
tail /var/log/syslog  | cut -d' ' -f5-           ! split line with spaces ( -d' ') and print field no. 5 and everything that comes after it (-f5-)

cut -d' ' -f5- /var/log/syslog | sort | uniq -c | sort -nr | head
                                                 ! find out which process message occur most often
                                                 
                                                 
