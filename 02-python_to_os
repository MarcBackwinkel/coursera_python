pip install module_name

Importing Modules:
import module      # when module is imported, __init__.py is read

module: requests                # module for http-requests
import requests
response = requests.get("http://www.google.com")
print(response.text)

module: datetime                 # convert between different time formats

module: arrow                      # date handling
date = arrow.get('2022-08-10', 'YYYY-MM-DD')     # parse string to date
date.shift(weeks=+6).format('MMM DD YYYY')   # add 4 weeks to date and 
                                                                                     # format output
 
module: pil                             # python image library
image = PIL.Image.open('picture.jpg')
print(image.size, image.format)

module: shutil                        # system health
du = shutil.disk_usage('/')
module: psutil                        # performance monitoring
psutil.cpu_percent(0.1)


Running python-modules on Linux
use shebang: #!/usr/bin/env python3
chmod +x                             # mark script as executable
./script.py


Working with Files
file = open("file.txt","w")        # second parameter: r -> read mode (default), w -> write only mode, a -> append, r+ -> read-write mode
                                    # if file is opened for writing and it already exists, the old contents are deleted as soon as the file is opened
file.readline()                    # reads file line by line, puts an \n automatically to the end <-- can be removed with strip()
file.read()                        # reads file till the end
lines = file.readlines()           # reads all lines of a file and returns them as list
file.write("text")                 # returns number of characters that were written
file.close()
or
with open("file.txt") as file:      # with automatically closes file after with block is left
    print(file.readline())
    
    
Working with the file system
import os
os.getcwd()                            # get current working directory
os.listdir("dir")                      # returns a list of all files in the directory
path = os.path.join("dir", "file.txt") # combines directory and file name os independently
os.path.isdir("is_this_a_dir")         # check if parameter is a directory, eventually combine name with os.path.join("dir", "file.txt")
os.mkdir("new_dir")
os.rmdir("dir_to_remove")              # will only remove a directory if the directory is empty
os.chdir("new_dir")
os.path.exists("filename.txt")         # check if a file exists, returns True / False
os.path.getsize("filename.txt")        # filesize
ts = os.path.getmtime("filename.tx")   # last timestamp of modification; timestamp in milliseconds
    datetime.datetime.fromtimestamp(ts) # format timestamp as actual date / attention: previously import datetime-module!    
abs_path = os.path.abspath("file.txt") # returns absolute path to file
os.remove("file_to_be_deleted.txt")    # remove file
os.rename("old_name.txt", "new_name.txt")


csv-Files
import csv
f = open("csv_file.txt")                # use attributes w and a to write to csv-file
csv_f = csv.reader(f)
for row in csv_f:                     # read csv-file
    col1, col2, col3 = row              # unpack values, col1 == row[0]
    
with open('file.csv', 'w') as file_csv:  # write to a csv-file with a list
    writer = csv.writer(file_csv)
    writer.writerow([value1, value2, value3])    # writes a single row to a csv file
    writer.writerows([[value1, value2, value3], [value4, value5, value6]])     # write list of lists to a csv file 
    
with open('file.csv') as file_csv:  # read csv-file into a dict
    reader = csv.DictReader(file_csv)     # reads a file into a dict, using first row as keys
    
with open('file.csv', 'w') as file_csv:  # write to csv-file using a dict
    writer = csv.DictWriter(file_csv, fieldnames=keys)     # keys is a list of the key names
    writer.writeheader()
    writer.writerows(dict)               # dict is a dictionary, which keys are identical to the list-variable keys
    
#=============================================================================================================================================================

Regular Expressions

RegEx
.      matches any character (wildcard)
^      position must match the beginning
$      position must match the end
()     capturing group
[]     define a range, e.g. [pP], [a-z], [a-zA-Z0-9], [.,:;?!]
[^]    define a range which is excluded [^a-zA-Z ] (exclude any letter - case insensitive - and space)
|      separate words to find
repeated match qualifiers
*      match any number of chars incl. zero times; it works "greedy" (matches as many characters as possible)
+      match any number of chars at least one time; it works "greedy" (matches as many characters as possible)
?      character before is optional, like p? or [a-z]?
{}     numeric repetition qualifiers, e.g. {5}, {1,5}
Escpaing characters
.*+?^$[]{}
Special Sequences
\b     word boundaries, e.g. r'\b[a-zA-Z]{5}\b' all words with exactly 5 characters
\d     digits
\s     whitespace characters (like space, tab, newline \n
\w     any alphanumeric character (incl. letters, numbers, underscores)

import re
result = re.search(r'regex_as_string', text_to_be_looked_at)    # r -> Rawstring shall not be interpreted by Python but shall be handed to the function as is
                                                                # if Rawstring is a pure text string, then the 'r' would not be needed
                                                                # but: Always use Rawstrings for regular expressions in Python!!!
                                                                # result is a re.Match object <; span, match = matching_string>; if nothing is found None is returned
                                                                # re.Match object is a tuple, [0]: all results, [1]: first group, [2]: second group, ...
                                                                         # groups are built acc. to parenthesis in reg ex-string, e.g. r'(\w+), (\w+)' 
re.search(r'regex', text, re.IGNORECASE())  # search case insensitive
re.findall(r'regex', text)                  # find all matches, returns a list with all results
re.split(r'regex', text)                    # splits a text into different strings using regex
re.sub(r'regex', new_text, text)            # replaces regex-strings in text by new_text
                                            # new_text may also be a regex, e.g. to access captured groups: r'\2 \1' (second_group first_group)

bash-Commands
grep
-i  : search case insensitive
egrep                                       # also supports + and ? as repeated match qualifiers 

#=============================================================================================================================================================

Data Streams

I/O Streams:     STDIN, STDOUT, STERROR

user_input = input("This text will be shown on screen to the user')       # input always returns a string; must be explicitely parsed to other data types

Access Environment Variables in Python
import os
path = os.environ.get("PATH", "default_value") # could also be accessed via os.environ['PATH'], but the get-methon returns a default value if the value is not defined
                                                 # while accessing the non-existing value directly would return an error
import sys
sys.argv                                         # access arguments from the function call, returns a tuple
sys.exit(failure_code)                           # exit a program while returning a failure code
                                            
run bash functionality in Python
import subprocess                               # parent process is blocked while child process is executed
subprocess.run(['date'])                         # print actual date, equal to command date in bash
subprocess.run(['sleep', '2'])                   # called with two arguments (from 2nd parameter on: Command Line Arguments)

result = subprocess.run(['ls', 'unknown_file')]  # one bash command with one parameter throws an error
print(result.returncode)                         # returncode of child process made visible in python

result = subprocess.run(['host', '8.8.8.8'], capture_output=True)      # capture_output delivers output in result.stdout
print(result.returncode)                         # as already seen
print(result.stdout)                             # show output of child process in Python
                                                 # if output starts with b'' --> binary output (Python does not know which encoding to use)
                                                 # UTF-8 encoding: part of unicode standard that lists all possible characters that can be represented
print(result.stdout.decode())                    # convert binary format into given encoding, default: UTF-8
print(result.stdout.decode().split())            # split encoded output

result = subprocess.run(['rm', 'does_not_exist.py'], capture_output=True)     # throws an error
print(result.returncode)                         # != 0
print(result.stdout)                             # b''
print(result.stderr)                             # b"failure message" (in binary code)

#=============================================================================================================================================================

Bash commands

echo              # print 
  echo $?           # print info on $-variable which contains the error messega (0 - success, > 0 - error)
env               # show environment variables
export            # create new environment variable and make it visible to all processes, e.g. export ENV_VARIABLE=env_var_to_set
host              # return name to given ip address
rm                # remove file(s)
wc                # counts number of words, lines, ...
who               # prints the user who is currently logged in

