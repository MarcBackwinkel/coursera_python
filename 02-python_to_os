pip install module_name

Importing Modules:
import module      # when module is imported, __init__.py is read

import module sys               # The sys module provides information about the Python interpreter's constants, functions, and methods. 
import module os                # The os module provides a portable way of using operating system dependent functionality with Python.

module: requests                # module for http-requests
import requests
response = requests.get("http://www.google.com")
print(response.text)

module: datetime                 # convert between different time formats

module: arrow                      # date handling
date = arrow.get('2022-08-10', 'YYYY-MM-DD')     # parse string to date
date.shift(weeks=+6).format('MMM DD YYYY')   # add 4 weeks to date and 
                                                                                     # format output
 
module: pil                             # python image library
image = PIL.Image.open('picture.jpg')
print(image.size, image.format)

module: shutil                        # system health
du = shutil.disk_usage('/')
module: psutil                        # performance monitoring
psutil.cpu_percent(0.1)


Running python-modules on Linux
use shebang: #!/usr/bin/env python3
chmod +x                             # mark script as executable
./script.py


Working with Files
file = open("file.txt","w")        # second parameter: r -> read mode (default), w -> write only mode, a -> append, r+ -> read-write mode
                                    # if file is opened for writing and it already exists, the old contents are deleted as soon as the file is opened
file.readline()                    # reads file line by line, puts an \n automatically to the end <-- can be removed with strip()
file.read()                        # reads file till the end
lines = file.readlines()           # reads all lines of a file and returns them as list
file.write("text")                 # returns number of characters that were written
file.close()
or
with open("file.txt") as file:      # with automatically closes file after with block is left
    print(file.readline())
    
    
Working with the file system
import os
os.getcwd()                            # get current working directory
os.listdir("dir")                      # returns a list of all files in the directory
path = os.path.join("dir", "file.txt") # combines directory and file name os independently
os.path.isdir("is_this_a_dir")         # check if parameter is a directory, eventually combine name with os.path.join("dir", "file.txt")
os.mkdir("new_dir")
os.rmdir("dir_to_remove")              # will only remove a directory if the directory is empty
os.chdir("new_dir")
os.path.exists("filename.txt")         # check if a file exists, returns True / False
os.path.getsize("filename.txt")        # filesize
ts = os.path.getmtime("filename.tx")   # last timestamp of modification; timestamp in milliseconds
    datetime.datetime.fromtimestamp(ts) # format timestamp as actual date / attention: previously import datetime-module!    
abs_path = os.path.abspath("file.txt") # returns absolute path to file
os.remove("file_to_be_deleted.txt")    # remove file
os.rename("old_name.txt", "new_name.txt")


csv-Files
import csv
f = open("csv_file.txt")                # use attributes w and a to write to csv-file
csv_f = csv.reader(f)
for row in csv_f:                     # read csv-file
    col1, col2, col3 = row              # unpack values, col1 == row[0]
    
with open('file.csv', 'w') as file_csv:  # write to a csv-file with a list
    writer = csv.writer(file_csv)
    writer.writerow([value1, value2, value3])    # writes a single row to a csv file
    writer.writerows([[value1, value2, value3], [value4, value5, value6]])     # write list of lists to a csv file 
    
with open('file.csv') as file_csv:  # read csv-file into a dict
    reader = csv.DictReader(file_csv)     # reads a file into a dict, using first row as keys
    
with open('file.csv', 'w') as file_csv:  # write to csv-file using a dict
    writer = csv.DictWriter(file_csv, fieldnames=keys)     # keys is a list of the key names
    writer.writeheader()
    writer.writerows(dict)               # dict is a dictionary, which keys are identical to the list-variable keys
    
#=============================================================================================================================================================

Regular Expressions

RegEx
.      matches any character (wildcard)
^      position must match the beginning
$      position must match the end
()     capturing group
[]     define a range, e.g. [pP], [a-z], [a-zA-Z0-9], [.,:;?!]
[^]    define a range which is excluded [^a-zA-Z ] (exclude any letter - case insensitive - and space)
|      separate words to find
repeated match qualifiers
*      match any number of chars incl. zero times; it works "greedy" (matches as many characters as possible)
+      match any number of chars at least one time; it works "greedy" (matches as many characters as possible)
?      character before is optional, like p? or [a-z]?
{}     numeric repetition qualifiers, e.g. {5}, {1,5}
Escpaing characters
.*+?^$[]{}
Special Sequences
\b     word boundaries, e.g. r'\b[a-zA-Z]{5}\b' all words with exactly 5 characters
\d     digits
\s     whitespace characters (like space, tab, newline \n
\w     any alphanumeric character (incl. letters, numbers, underscores)

import re
result = re.search(r'regex_as_string', text_to_be_looked_at)    # r -> Rawstring shall not be interpreted by Python but shall be handed to the function as is
                                                                # if Rawstring is a pure text string, then the 'r' would not be needed
                                                                # but: Always use Rawstrings for regular expressions in Python!!!
                                                                # result is a re.Match object <; span, match = matching_string>; if nothing is found None is returned
                                                                # re.Match object is a tuple, [0]: all results, [1]: first group, [2]: second group, ...
                                                                         # groups are built acc. to parenthesis in reg ex-string, e.g. r'(\w+), (\w+)' 
re.search(r'regex', text, re.IGNORECASE())  # search case insensitive
re.findall(r'regex', text)                  # find all matches, returns a list with all results
re.split(r'regex', text)                    # splits a text into different strings using regex
re.sub(r'regex', new_text, text)            # replaces regex-strings in text by new_text
                                            # new_text may also be a regex, e.g. to access captured groups: r'\2 \1' (second_group first_group)

bash-Commands
grep
-i  : search case insensitive
egrep                                       # also supports + and ? as repeated match qualifiers 

#=============================================================================================================================================================

Data Streams

I/O Streams:     STDIN, STDOUT, STERROR

user_input = input("This text will be shown on screen to the user')       # input always returns a string; must be explicitely parsed to other data types

Access Environment Variables in Python
import os
path = os.environ.get("PATH", "default_value") # could also be accessed via os.environ['PATH'], but the get-methon returns a default value if the value is not defined
                                                 # while accessing the non-existing value directly would return an error
import sys
sys.argv                                         # access arguments from the function call, returns a tuple
logfile = sys.argv[1]                            # argument 1 contains the logfile, e.g. bash:~$ ./run_python.py syslog
sys.exit(failure_code)                           # exit a program while returning a failure code
                                            
run bash functionality in Python
import subprocess                               # parent process is blocked while child process is executed
subprocess.run(['date'])                         # print actual date, equal to command date in bash
subprocess.run(['sleep', '2'])                   # called with two arguments (from 2nd parameter on: Command Line Arguments)

result = subprocess.run(['ls', 'unknown_file')]  # one bash command with one parameter throws an error
print(result.returncode)                         # returncode of child process made visible in python

result = subprocess.run(['host', '8.8.8.8'], capture_output=True)      # capture_output delivers output in result.stdout
print(result.returncode)                         # as already seen
print(result.stdout)                             # show output of child process in Python
                                                 # if output starts with b'' --> binary output (Python does not know which encoding to use)
                                                 # UTF-8 encoding: part of unicode standard that lists all possible characters that can be represented
print(result.stdout.decode())                    # convert binary format into given encoding, default: UTF-8
print(result.stdout.decode().split())            # split encoded output

result = subprocess.run(['rm', 'does_not_exist.py'], capture_output=True)     # throws an error; subprocess.run returns a CompletedProcess-object
print(result.returncode)                         # != 0
print(result.stdout)                             # b''
print(result.stderr)                             # b"failure message" (in binary code)


Process: Take environment variables, add / change them as needed and hand them over to the child process
import os
my_env = os.environ.copy()
my_env['PATH'] = os.pathsep.join(["/own/path/", my_env['PATH']])        # add own_path to enviroment variable, original environment is NOT changed
                                                                        # pathsep = path seperator
result = subprocess.run(["myapp"], env = my_env)

what can also be changed?
cwd      - set own current working directory
timeout  - set own timeout, e.g. if system hangs up
shell    - true, will first execute an instance of the system default shell and run the given command inside of it

#=============================================================================================================================================================

Error Handling

try:
    f = open(filename)
except OSError:
    return None
    
# raising own errors
if not wanted_condition:
    raise ValueError('descriptive error message')
    


#=============================================================================================================================================================

Testing

Automated Testg :        Automate Process of checking if the returned value matches the expectations
                         Test Cases are built automatically

Unit Tests:              Type of Automated Testing
                         Used to verify that small, isolated parts of a program are correct
                         Test should never modify the production environment; if the environment is needed tests run in a test environment


Edge cases:               Inputs to our code that produce unexpected results, and are found at the extreme ends of the ranges of input we 
                          imagine our programs will typically work with
                          
White-box testing         also sometimes called clear-box or transparent testing relies on the test creators knowledge of the software being 
                          tested to construct the test cases.

black-box testing         the software being tested is treated like an opaque (undurchsichtig) box. Black-box tests are written with an 
                          awareness of what the program is supposed to do, its requirements or specifications, but not how it does it.

test script.py with a seperate script, e.g. script_test.py ----------------------------------------------------------------------

>> script_test.py
#! ...
from script import function_to_test
import unittest                        # Python module for testing

class TestFunctionToTest(unittest.TestCase):        # write own test function that inherits from unittest class
 
# assertEqual
    def test_case_1(self):                          # function name must start with "test" to be taken into account by the unittest module
        testcase = "testcase for function_to_test"
        expected = "expected return value from function to test"
        self.assertEqual(function_to_test(testcase), expected)      # assertEqual is inherited from TestCase class
        
# assert                                                        # depending on the state of the program an error is raised
assert type(username) == str, "username must be a string"     # also helpful for debugging

# assertRaises                                                  # checks if an error is raised
self.assertRaises(ValueError, function_to_test, para1, para2)   # checks if a ValueError is raised with given para1 and para2

        
unittest.main()  # start Test

------------------------------------------------------------------------------------------------------------------------------------

Integration Tests:        after units are tested here the all-in-all is tested
                          is maybe performed in own test environment
                          interactivity between different modules is tested
                          Verifying an automation script works well with the overall system and external entities

Regression Tests:         test is performed, bug is fixed, test is re-performed and checked that the bug is gone
                          A test that is written after a bug has been identified in order to ensure the bug doesn't show up again later is called Reg. Test

Smoke Tests               or build verification tests
                          Does the program run? Comes from hardware development (if there is smoke there is fire!)
                          This test finds out if the program can run in its basic form before undergoing more refined test cases.
                          
Load tests                Scripts performs well if there is a high load on the system
                          type of software testing used to verify the software’s ability to behave well under significantly stressed testing conditions

Test suite                Many tests that work together, a suite of tests

Test-Driven Development:  TDD
                          First: create Tests, that later code shall succeed; Then: write the code
                          
Continuous Integration:   When engineers submit their code, it's integrated into the main repository and tests are automatically run 
                          against it to spot bugs and errors in a process called Continuous Integration. 
                          Although useful, setting up a continuous integration process can be a big undertaking.





#=============================================================================================================================================================

Bash commands

cronjobs          # schedule based scripts on UNIX operating systems
echo              # print 
  echo $?           # print info on $-variable which contains the error messega (0 - success, > 0 - error)
env               # show environment variables
export            # create new environment variable and make it visible to all processes, e.g. export ENV_VARIABLE=env_var_to_set
host              # return name to given ip address
rm                # remove file(s)
wc                # counts number of words, lines, ...
who               # prints the user who is currently logged in

