Some Definitions:

Scale           Being able to scale what we do means that we can keep achieving larger impacts with the same amount of effort
                A scalable system is a flexible one!

                To find out if a system is scalable, you could ask following questions:
                - Will adding more servers increase the capacity of the service?
                - How are new servers prepared, installed, and configured? 
                - How quickly can you set up new computers to get them ready to be used? 
                - Could you deploy a hundred servers with the same IT team that you have today? 
                - Or would you need to hire more people to get it done faster? 
                - Would all the deployed servers be configured exactly the same way?

Automation      An essential tool for keeping up with the infrastructure needs of a growing business.

Configuration Management (some Tools: Puppet, Chef, Ansible, CFEngine)
                - define configuration rules
                - let automation apply those rules on all machines (also called "nodes")

                -> Another important aspect of configuration management is that operations should be idempotent. 
                   In this context, an idempotent action can be performed over and over again without changing the system after the first time 
                   the action was performed, and with no unintended side effects.

                - Test and repair paradigm: first test if an action is needed on client and - only then - perform action (repair)
                - Puppet is stateless: Each Puppet run is independent of the previous one, and the next one. Every run just depends on currently colledted facts.

Infrastructure as Code 
                When all of the configuration necessary to deploy and manage a node in the infrastructure is stored in version control.
                Managing your Infrastructure as Code means that your fleet of nodes are 
                    - consistent,
                    - versioned, 
                    - reliable and 
                    - repeatable. 
                Instead of being seen as precious or unique, machines are treated as replaceable resources that can be deployed on-demand through the automation. 
                Any infrastructure that claims to be scalable must be able to handle the capacity requirements of growth.

====================================================================================================================================================================================
Puppet

Managing the configurations of computers and a fleet of machines.

          |-> process---|
          |  Manifests  |
          |            \|/
        Puppet master (service)
           ^            |
    sends  |            |   generates Catalog
    Facts  |            |
           |           \|/
        Puppet agent (client)
 (uses "Providers" to apply rules to local system)


 Puppet Agent       every physical machine, VM, Server, Routers, ... that have a puppet agent installed and can apply the rules

Facts               Variables that represent characteristics of the system
Providers           Puppet assigns providers according to predefined rules for the resource type and data collected from the system such as the family of the underlying operating system.
                    Providers may be package managers for installation of software, e.g. apt, yum

Resources           The basic unit for modeling that we want to manage (e.g. 'package' or 'file' keyword is a resource)
                    The most basic unit in Puppet is a resource, such as user, group, file, service or package.

Puppet Syntax:      class class_name {
                        resource { 'title_of_resource': 
                            attribute1 => set_value1,
                            attribute2 => set_value2,
                            ...
                        }
                    }

Puppet uses a declarative language because we declare the state that we want to achieve rather than the steps to get there.
(vs. Python, etc. being procedural languages.)

Classes:            group related resources
                    more easily understand the configuration and make changes in the future

Resources:
    exec                     # runs a specific command                  <-- be careful as this resource might not be idempotent
    file
    package
    service


Attributes ==> values:
    content => some_value               # content to be in e.g. a file
    ensure => absent                    # a resource will be removed
    command => command                  # command to be executed in an exec resource, e.g. 'mv file1 Desktop/file1', combine with attribute "onlyif" to make it idempotent
    ensure => directory                 # this resource must be available on the client and being a directory
    ensure => file                      # this resource must be available on the client and being a file
    ensure => installed
    ensure => latest                    # install latest version
    ensure => purged
    ensure => running                   # start a service if not already running
    mode => '0644'                      # set special rights, rights for owner, group, others (rwx)
    onlyif => command                   # performs command only if it is possible  <-- this is idempotent and will not finish with an error
    replace => true                     # an existing file will be overwritten


Puppet can provide, install and run a service:
class ntp {                     # ntp: Network Time Protocol: method computers uses to synchronize clocks
    package {'ntp':
        ensure => latest,
    }
    file {'etc/ntp.conf':
        source => 'link',
        replace => true,
    }
    service {'ntp':
        enable: true,
        ensure => running,
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------
Puppet - Domain Specific Language (DSL)

Python, Java, Ruby, Go, .... are General purpose languages
vs.
Domain Specific Languages       A programming language that is more limited in scope

DSL for Puppet defines
    - when
    - how 
      to apply configuration management rules to our devices

    - Variables                 always written as $var
    - Conditional Statements
    - Functions

    - Facts                     Variables that represent characteristics of the system 
                                adress facts in DSL with $facts['fact_name']
                                facts are hashes (equivalent to dictionaries in Python)
                                A fact is a hash that stores information about the details of a particular system.

Facts:
    $fact['is_virtual']         # checks if the system is a virtual machine


------------------------------------------------------------------------------------------------------------------------------------------------
local usage of puppet

Installation:       sudo apt install puppet-master
Puppet Files:       called "Manifest", always ends on .pp
Manifest:           a file in Puppet
Module:             a collection of manifests and associated data always starts with a file init.pp
                        and it should define a class with the same name as the module that you're creating
Template:           files that are preprocessed before they've been copied into the client machines

bash:> vim tools.pp

package {'htop':            # this package ensures that the htop command is present on the computer
    ensure => present,
}

bash:> sudo puppet apply -v tools.pp           # -v: verbose output

Catalog                The list of rules that are generated for one specific computer once the server has evaluated 
                            all variables, conditionals, and functions

Resource Relationship:
We write resource types in lowercase when declaring them, but capitalize them when referring to them from another resource's attributes.

class ntp {
    package {'ntp':
        ensure => latest,
    }
    file {'/etc/ntp.conf':
        ...
        require => Package['ntp'],             # requires previoulsy defined package
        notify => Service['ntp],               # all relationships like Package and Service are written with a capital first letter
                                               #   while the relevant resources (package, file, service) are written with a first lower letter
                                               # When defining resource types, we write them in lowercase, then capitalize them when referring 
                                               #   to them from another resource attribute.
    }
    service {'ntp':
        ...
        require => File['/etc/ntp.conf'],      # requires previoulsy defined file
        ...
    }
}

include ntp                                    # tell puppet that the rules of the class shall be applied

------------------------------------------------------------------------------------------------------------------------------------------------
modules                         # A module is a collection of resources, and associated data used to expand the functionality of Puppet.
|--module-name
    |--files                    #  files folder in a module will contain files that wonâ€™t need to be changed like configuration files.  
    |   |--module-name.comf
    |
    |--lib                      # new functions added after installing a new module can be found in the lib folder in the directory of the new module.
    |   |--adds_functions_and_facts_already_shipped_by_puppet
    |
    |--manifests                
    |   |--init.pp              # contains a class with a name of the module-name
    |
    |--templates                # Templates are documents that combine code, system facts, and text to render a configuration output fitting predefined rules.  
    |   |                       # Templates are documents that combine code, data, and literal text to produce a final rendered output. The goal of a template 
    |   |                       #       is to manage a complicated piece of text with simple inputs
    |   |--templates.file
    |
    |--metadata.json            #  includes some additional data about the module we just installed, like which versions of which operating systems it's compatible with

Templates
Templates are written in a templating language, which is specialized for generating text from data. Puppet supports two templating languages:
Embedded Puppet (EPP) uses Puppet expressions in special tags. It's easy for any Puppet user to read, but only works with newer Puppet versions. (â‰¥ 4.0, or late 3.x versions with future parser enabled.)
Embedded Ruby (ERB) uses Ruby code in tags. You need to know a small bit of Ruby to read it, but it works with all Puppet versions.

# there are predefined modules in puppet
# install them like e.g. sudo apt install puppet-module-puppetlabs-apache
# module files are stored under: /usr/share/puppet/modules.available/puppetlabs-apache
# use predefined modules by creating own module, e.g. webserver.pp with only one line

        include ::apache                       # double colon before name shows puppet that this is a GLOBAL module

# then apply with: sudo puppet apply -v webserver.pp

------------------------------------------------------------------------------------------------------------------------------------------------
Deploying Puppets to Clients

Node            Any System where we can run a Puppet agent 


Deploy different puppet rules on different machines by:
    - conditionally apply rules based on facts from the machines
    - Node definitions:

                node default {
                    class { 'sudo':  }                                                      # include class with no additional settings
                    class { 'ntp':                                                          # include class and define additional parameters
                        servers => ['ntp1.example.com','ntp2.example.com'] }
                }
                node webserver.example.com {                                                # specific node is defined by FQDN: fully qualified domain name
                                                                                            # this node will only be applied to machines that match the FQDN
                    class { 'sudo':  }      # include class with no additional settings
                    class { 'ntp':          # include class and define additional parameters
                        servers => ['ntp1.example.com','ntp2.example.com'] 
                    }
                    class { 'apached': }
                }

    Node definitions are usually stored in a file called "/site.pp" (<- it is not part of any module)

# How is ensured that puppet receives valid information about a computer name (security issue!!!)
--> Puppet uses PKI (Publik Key Infrastructure) / SSL (Secure Sockets Layer)
        each machine has a    -> private key               -> public key

        Certificate Authority (CA) verifies the identities of the machines --> create Certificate that states the public key goes with the machine
        take the CA from Puppet or an external one

        Certifocate Authority:  The CA either queues a certificate request for manual validation, or uses pre-shared data to verify before sending 
                                    the certificate to the agent.

        - CA becomes active when a node checks in to the puppet master for the first time
        - CA requests a certificate
        - Puppet master creates Certificate for Node if identity can be verified (by System's admin or an automatic process)
        - now the Node has a valid certificate which it can use to identify itself when requesting a catalogue

--> why is security so important
        - Puppet Rules may contain confidential content
        - being sure to only use correct machines in network (no rogue machines)

In Test Environment Puppet can be configured to automatically sign every request (but NEVER do this in a productive environement)
--> sudo puppet config --section master set autosign true

BETTER BE SAFE THAN SORRY | vs. | Besser um Verzeichung bitten als um Erlaubnis (Charly Harper).

---------------------------------------------------------------------------------------------------------------------------------------
Setting up Puppet Client and Masters

on Puppet Master (ubuntu.example.com):
    TEST ONLY:  sudo puppet config --section master set autosign true
    ssh webserver.example.com

on Puppet Agent (webserver.example.com):
    sudo apt install puppet                                 # install Puppet Agent
    sudo puppet config set server ubuntu.example.com        # set Puppet Master
    sudo puppet agent -v --test                             # test connection to Puppet Master

on Puppet Master (ubuntu.example.com):
    create site.pp

    node webserver.example.com {
        class {'apache':}
    }
    node default {}

on Puppet Agent (webserver.example.com):
    sudo puppet agent -v --test                             # Test - OK?
    
    # systemctl process which lets us enable the services actually running
    sudo systemctl enable puppet                            # start puppet every time the system is rebooted so puppet agent pulls updates to config files automatically
    sudo systemctl start puppet                             # now, manually start ctl process
    sudo systemctl status puppet                            # see actual status, is ctl started?

Production              the parts of the infrastructure where a service is executed and served to its users

machine_info module     gathers some information from the machine using Puppet facts and then stores it in a file.


# Rolling out new / changed Puppet Scripts to Production:
    - Test Environment
        - check syntax of script with "puppet purser validate" command
        - run the rules using the "no op"-parameter (the name comes from no operations and it makes puppet simulate what it would do without actually doing it. You can look at 
                                                        the list of actions that it would take and check that they're exactly what you wanted puppet to do)
        - apply rules on test machines (Puppet rspec Tests: We can set the facts involved different values and check that the catalog ends up stating what we wanted it to)

    - Baked In Environments in Puppet
    
    - push to PROD in batches / canaries
        - use fact "early adopters"


---------------------------------------------------------------------------------------------------------------------------------------
The Cloud

Advantages of using cloud service:
    Cloud services provide many advantages, like
    - outsourcing support and maintenance, simplifying configuration management, and letting the provider take care of security.
    - simplifying configuration management, outsourcing support and maintenance, and letting the provider take care of security.
    - putting the provider in charge of security.


Software as a Service (SaaS)            When a Cloud provider delivers an entire application or program to the customer, e.g. Gmail, Dropbox, MS365
                                        Cloud Provider has full control of how the application runs
Platform as a Service (PaaS)            When a Cloud provider offers a preconfigured platform to the customer, e.g. SQL database as a Service, Managed Web Apps
                                                (famous Managed Web Apps: Amazon Elastic Beanstalk, Microsoft App Service, Google App Engine)
                                        We are in charge of the Code, but we are not responsible for running the application
Infrastructure as a Service (IaaS)      When a Cloud provider supplies only the bare-bones computing experience, e.g. run VM in the Cloud
                                        We decide the OS of the machine, the software that is running, and so on ...
                                        Very helpful for "Lift and Shift" Strategy:  When we migrate from traditional server configurations to the Cloud, 
                                                        we lift the current configuration and shift it to a virtual machine

Public Cloud                            The cloud service provided by to you by a third party (services are offered to the public)
Private Cloud                           When your company owns the services and the rest of the infrastructure, whether that's on-site or in a remote data center
Hybrind Cloud                           A mixture of both public and private clouds (it is important that services are integrated seamingless)
Multi-Cloud                             A mixture of public and/or private clouds across vendors (gives extra protection but may be more expensive)

Containers                              Applications that are packaged together with their configuration and dependencies
                                        A virtualized environment containing applications and configurations that can run quickly and reliably on any computing environment.
                                        If application runs in a container it can run in a container everywhere!


DataCenters are located in REGIONS and in ZONES; choose a DataCenter next to you due to:
    - latency
    - eventually law policy reasons
    - place depending Servers next to each other


Scaling in the Cloud

Capacity                How much the service can deliver

Scaling can be done
    - horizontally      add more node to a specific service, more servers
    - vertically        make nodes bigger (increase capacity, e.g. memory, cpu, disk size)

    - automatically     the service offered by the Cloud provider will use metrics to automatically increase or decrease the capaxity of the system
                        (send right quotas for autoscaling system)
    - manually          changes are made by humans instead of software (less complicated, but needs monitoring and might not scale quick enough)


Important for Selection of Cloud Provider
    - level of support (in case of any problems)
    - Security measures cloud provider has taken (certifications like SOC 1, ISO 27001, ...)

        ! We should always use reasonable judgment to protect the machines that we deploy, whether that's on physical servers running on-premise or on virtual machines in the Cloud !















