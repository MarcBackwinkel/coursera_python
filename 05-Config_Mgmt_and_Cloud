Some Definitions:

Scale           Being able to scale what we do means that we can keep achieving larger impacts with the same amount of effort
                A scalable system is a flexible one!

                To find out if a system is scalable, you could ask following questions:
                - Will adding more servers increase the capacity of the service?
                - How are new servers prepared, installed, and configured? 
                - How quickly can you set up new computers to get them ready to be used? 
                - Could you deploy a hundred servers with the same IT team that you have today? 
                - Or would you need to hire more people to get it done faster? 
                - Would all the deployed servers be configured exactly the same way?

Automation      An essential tool for keeping up with the infrastructure needs of a growing business.

Configuration Management (some Tools: Puppet, Chef, Ansible, CFEngine)
                - define configuration rules
                - let automation apply those rules on all machines (also called "nodes")

                -> Another important aspect of configuration management is that operations should be idempotent. 
                   In this context, an idempotent action can be performed over and over again without changing the system after the first time 
                   the action was performed, and with no unintended side effects.

                - Test and repair paradigm: first test if an action is needed on client and - only then - perform action (repair)
                - Puppet is stateless: Each Puppet run is independent of the previous one, and the next one. Every run just depends on currently colledted facts.

Infrastructure as Code 
                When all of the configuration necessary to deploy and manage a node in the infrastructure is stored in version control.
                Managing your Infrastructure as Code means that your fleet of nodes are 
                    - consistent,
                    - versioned, 
                    - reliable and 
                    - repeatable. 
                Instead of being seen as precious or unique, machines are treated as replaceable resources that can be deployed on-demand through the automation. 
                Any infrastructure that claims to be scalable must be able to handle the capacity requirements of growth.

====================================================================================================================================================================================
Puppet

Managing the configurations of computers and a fleet of machines.

          |-> process---|
          |  Manifests  |
          |            \|/
        Puppet master (service)
           ^            |
    sends  |            |   generates Catalog
    Facts  |            |
           |           \|/
        Puppet agent (client)
 (uses "Providers" to apply rules to local system)


 Puppet Agent       every physical machine, VM, Server, Routers, ... that have a puppet agent installed and can apply the rules

Facts               Variables that represent characteristics of the system
Providers           Puppet assigns providers according to predefined rules for the resource type and data collected from the system such as the family of the underlying operating system.
                    Providers may be package managers for installation of software, e.g. apt, yum

Resources           The basic unit for modeling that we want to manage (e.g. 'package' or 'file' keyword is a resource)
                    The most basic unit in Puppet is a resource, such as user, group, file, service or package.

Puppet Syntax:      class class_name {
                        resource { 'title_of_resource': 
                            attribute1 => set_value1,
                            attribute2 => set_value2,
                            ...
                        }
                    }

Puppet uses a declarative language because we declare the state that we want to achieve rather than the steps to get there.
(vs. Python, etc. being procedural languages.)

Classes:            group related resources
                    more easily understand the configuration and make changes in the future

Resources:
    exec                     # runs a specific command                  <-- be careful as this resource might not be idempotent
    file
    package
    service


Attributes ==> values:
    content => some_value               # content to be in e.g. a file
    ensure => absent                    # a resource will be removed
    command => command                  # command to be executed in an exec resource, e.g. 'mv file1 Desktop/file1', combine with attribute "onlyif" to make it idempotent
    ensure => directory                 # this resource must be available on the client and being a directory
    ensure => file                      # this resource must be available on the client and being a file
    ensure => installed
    ensure => latest                    # install latest version
    ensure => purged
    ensure => running                   # start a service if not already running
    mode => '0644'                      # set special rights, rights for owner, group, others (rwx)
    onlyif => command                   # performs command only if it is possible  <-- this is idempotent and will not finish with an error
    replace => true                     # an existing file will be overwritten


Puppet can provide, install and run a service:
class ntp {                     # ntp: Network Time Protocol: method computers uses to synchronize clocks
    package {'ntp':
        ensure => latest,
    }
    file {'etc/ntp.conf':
        source => 'link',
        replace => true,
    }
    service {'ntp':
        enable: true,
        ensure => running,
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------
Puppet - Domain Specific Language (DSL)

Python, Java, Ruby, Go, .... are General purpose languages
vs.
Domain Specific Languages       A programming language that is more limited in scope

DSL for Puppet defines
    - when
    - how 
      to apply configuration management rules to our devices

    - Variables                 always written as $var
    - Conditional Statements
    - Functions

    - Facts                     Variables that represent characteristics of the system 
                                adress facts in DSL with $facts['fact_name']
                                facts are hashes (equivalent to dictionaries in Python)
                                A fact is a hash that stores information about the details of a particular system.

Facts:
    $fact['is_virtual']         # checks if the system is a virtual machine


------------------------------------------------------------------------------------------------------------------------------------------------
local usage of puppet

Installation:       sudo apt install puppet-master
Puppet Files:       called "Manifest", always ends on .pp
Manifest:           a file in Puppet
Module:             a collection of manifests and associated data always starts with a file init.pp
                        and it should define a class with the same name as the module that you're creating
Template:           files that are preprocessed before they've been copied into the client machines

bash:> vim tools.pp

package {'htop':            # this package ensures that the htop command is present on the computer
    ensure => present,
}

bash:> sudo puppet apply -v tools.pp           # -v: verbose output

Catalog                The list of rules that are generated for one specific computer once the server has evaluated 
                            all variables, conditionals, and functions

Resource Relationship:
We write resource types in lowercase when declaring them, but capitalize them when referring to them from another resource's attributes.

class ntp {
    package {'ntp':
        ensure => latest,
    }
    file {'/etc/ntp.conf':
        ...
        require => Package['ntp'],             # requires previoulsy defined package
        notify => Service['ntp],               # all relationships like Package and Service are written with a capital first letter
                                               #   while the relevant resources (package, file, service) are written with a first lower letter
                                               # When defining resource types, we write them in lowercase, then capitalize them when referring 
                                               #   to them from another resource attribute.
    }
    service {'ntp':
        ...
        require => File['/etc/ntp.conf'],      # requires previoulsy defined file
        ...
    }
}

include ntp                                    # tell puppet that the rules of the class shall be applied

------------------------------------------------------------------------------------------------------------------------------------------------
modules                         # A module is a collection of resources, and associated data used to expand the functionality of Puppet.
|--module-name
    |--files                    #  files folder in a module will contain files that wonâ€™t need to be changed like configuration files.  
    |   |--module-name.comf
    |
    |--lib                      # new functions added after installing a new module can be found in the lib folder in the directory of the new module.
    |   |--adds_functions_and_facts_already_shipped_by_puppet
    |
    |--manifests                
    |   |--init.pp              # contains a class with a name of the module-name
    |
    |--templates                # Templates are documents that combine code, system facts, and text to render a configuration output fitting predefined rules.  
    |   |--templates.file
    |
    |--metadata.json            #  includes some additional data about the module we just installed, like which versions of which operating systems it's compatible with

# there are predefined modules in puppet
# install them like e.g. sudo apt install puppet-module-puppetlabs-apache
# module files are stored under: /usr/share/puppet/modules.available/puppetlabs-apache
# use predefined modules by creating own module, e.g. webserver.pp with only one line

        include ::apache                       # double colon before name shows puppet that this is a GLOBAL module

# then apply with: sudo puppet apply -v webserver.pp

------------------------------------------------------------------------------------------------------------------------------------------------
Deploying Puppets to Clients

Node            Any System where we can run a Puppet agent 


Deploy different puppet rules on different machines by:
    - conditionally apply rules based on facts from the machines
    - Node definitions:

                node default {
                    class { 'sudo':  }                                                      # include class with no additional settings
                    class { 'ntp':                                                          # include class and define additional parameters
                        servers => ['ntp1.example.com','ntp2.example.com'] }
                }
                node webserver.example.com {                                                # specific node is defined by FQDN: fully qualified domain name
                                                                                            # this node will only be applied to machines that match the FQDN
                    class { 'sudo':  }      # include class with no additional settings
                    class { 'ntp':          # include class and define additional parameters
                        servers => ['ntp1.example.com','ntp2.example.com'] 
                    }
                    class { 'apached': }
                }

    Node definitions are usually stored in a file called "/site.pp" (<- it is not part of any module)

# How is ensured that puppet receives valid information about a computer name (security issue!!!)
--> Puppet uses PKI (Publik Key Infrastructure) / SSL (Secure Sockets Layer)
        each machine has a    -> private key               -> public key

        Certificate Authority (CA) verifies the identities of the machines --> create Certificate that states the public key goes with the machine
        take the CA from Puppet or an external one

        Certifocate Authority:  The CA either queues a certificate request for manual validation, or uses pre-shared data to verify before sending 
                                    the certificate to the agent.

        - CA becomes active when a node checks in to the puppet master for the first time
        - CA requests a certificate
        - Puppet master creates Certificate for Node if identity can be verified (by System's admin or an automatic process)
        - now the Node has a valid certificate which it can use to identify itself when requesting a catalogue

--> why is security so important
        - Puppet Rules may contain confidential content
        - being sure to only use correct machines in network (no rogue machines)

In Test Environment Puppet can be configured to automatically sign every request (but NEVER do this in a productive environement)
--> sudo puppet config --section master set autosign true

BETTER BE SAFE THAN SORRY | vs. | Besser um Verzeichung bitten als um Erlaubnis (Charly Harper).

---------------------------------------------------------------------------------------------------------------------------------------
Setting up Puppet Client and Masters

on Puppet Master (ubuntu.example.com):
    TEST ONLY:  sudo puppet config --section master set autosign true
    ssh webserver.example.com

on Puppet Agent (webserver.example.com):
    sudo apt install puppet                                 # install Puppet Agent
    sudo puppet config set server ubuntu.example.com        # set Puppet Master
    sudo puppet agent -v --test                             # test connection to Puppet Master

on Puppet Master (ubuntu.example.com):
    create site.pp

    node webserver.example.com {
        class {'apache':}
    }
    node default {}

on Puppet Agent (webserver.example.com):
    sudo puppet agent -v --test                             # Test - OK?
    
    # systemctl process which lets us enable the services actually running
    sudo systemctl enable puppet                            # start puppet every time the system is rebooted so puppet agent pulls updates to config files automatically
    sudo systemctl start puppet                             # now, manually start ctl process
    sudo systemctl status puppet                            # see actual status, is ctl started?





















